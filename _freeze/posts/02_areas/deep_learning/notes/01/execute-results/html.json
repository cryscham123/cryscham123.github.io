{
  "hash": "8b4c6acbbfe117d7b4f4d78569df9a6a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"신경망\"\ndate: 2025-03-18\ncategories: [\"deep learning\"]\n---\n\n\n\n\n![](/img/stat-thumb.jpg){.post-thumbnail}\n\n## 신경망이란\n\n- 퍼셉트론에서 가중치를 자동으로 학습하는 방법이다.\n- 입력층, 은닉층, 출력층으로 구성된다.\n\n앞에서 살펴본 퍼셉트론 함수를 다시 살펴보자.\n\n$$\ny = \\begin{cases} 0 & (b + w_1x_1 + w_2x_2 ≤ 0) \\\\ 1 & (b + w_1x_1 + w_2x_2 > 0) \\end{cases}\n$$\n\n이때, $y = h(b + w_1x_1 + w_2x_2)$로 표현하면 다음과 같이 표현할 수 있다.\n\n$$\nh(x) = \\begin{cases} 0 & (x ≤ 0) \\\\ 1 & (x > 0) \\end{cases}\n$$\n\n이때 $h(x)$는 활성화 함수(activation function)라고 한다.\n\n## 활성화 함수\n\n- 계단 함수(step function): 앞서 살펴본 함수\n\n::: {#301bc78b .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\ndef step_function(x):\n    return np.array(x > 0, dtype=int)\n\nprint(step_function(np.array([-1.0, 1.0, 2.0])))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 1]\n```\n:::\n:::\n\n\n::: {#061f9f8c .cell execution_count=2}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\nx = np.arange(-5.0, 5.0, 0.1)\ny = step_function(x)\nplt.plot(x, y)\nplt.ylim(-0.1, 1.1)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](01_files/figure-html/cell-3-output-1.png){width=571 height=411}\n:::\n:::\n\n\n- 시그모이드 함수: $h(x) = \\frac{1}{1 + \\exp(-x)}$\n\n::: {#26f93274 .cell execution_count=3}\n``` {.python .cell-code}\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\nx = np.arange(-5.0, 5.0, 0.1)\ny = sigmoid(x)\nplt.plot(x, y)\nplt.ylim(-0.1, 1.1)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](01_files/figure-html/cell-4-output-1.png){width=571 height=411}\n:::\n:::\n\n\n- 계단 함수와의 차이점\n    - 시그모이드가 더 부드러움\n- 계단 함수와의 공통점\n    - 입력이 작을 때는 0에 가깝고, 입력이 커지면 1에 가까워짐\n    - 입력이 아무리 작거나 커도 출력은 0에서 1 사이\n    - 비선형 함수 (선형 함수는 은닉층 업싱도 똑같이 구현할 수 있기 때문에 신경망에서 활성화 함수는 반드시 비선형 함수여야 함)\n\n- ReLU 함수: $h(x) = \\begin{cases} x & (x > 0) \\\\ 0 & (x ≤ 0) \\end{cases}$\n\n::: {#30227135 .cell execution_count=4}\n``` {.python .cell-code}\ndef relu(x):\n    return np.maximum(0, x)\n```\n:::\n\n\n- SoftMax 함수: $y_k = \\frac{\\exp(a_k)}{\\sum_{i=1}^{n} \\exp(a_i)}$\n\n::: {#c573200e .cell execution_count=5}\n``` {.python .cell-code}\ndef softmax(a):\n    exp_a = np.exp(a)\n    sum_exp_a = np.sum(exp_a)\n    y = exp_a / sum_exp_a\n    return y\n```\n:::\n\n\nsoftmax 함수는 값이 기하급수적으로 증가하기 때문에 쉽게 overflow가 발생할 수 있음.\n\n따라서 다음과 같이 개선이 필요함\n\n::: {#7c3423e2 .cell execution_count=6}\n``` {.python .cell-code}\ndef softmax(a):\n    c = np.max(a)\n    exp_a = np.exp(a - c)\n    sum_exp_a = np.sum(exp_a)\n    y = exp_a / sum_exp_a\n    return y\n```\n:::\n\n\nsofrmax 함수 출력의 총합은 1이고, 개별 출력은 0에서 1 사이이다.\n\n따라서 softmax 함수의 출력을 확률로 해석할 수 있다.\n\n여기서 softmax 함수는 입력 값의 대소관계가 유지된다는 성질이 있기 때문에, 사실 생략해도 상관없다.\n\n## 3층 신경망 구성\n\n입력층에서 1층으로 신호 전달\n\n::: {#6ab87e8f .cell execution_count=7}\n``` {.python .cell-code}\nX = np.array([1.0, 0.5])\nW1 = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]])\nB1 = np.array([0.1, 0.2, 0.3])\n\nA1 = np.dot(X, W1) + B1\nZ1 = sigmoid(A1)\n\nprint(A1)\nprint(Z1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.3 0.7 1.1]\n[0.57444252 0.66818777 0.75026011]\n```\n:::\n:::\n\n\n1층에서 2층으로 신호 전달\n\n::: {#a25f6f9b .cell execution_count=8}\n``` {.python .cell-code}\nW2 = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]])\nB2 = np.array([0.1, 0.2])\n\nA2 = np.dot(Z1, W2) + B2\nZ2 = sigmoid(A2)\n\nprint(A2)\nprint(Z2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.51615984 1.21402696]\n[0.62624937 0.7710107 ]\n```\n:::\n:::\n\n\n2층에서 출력층으로 신호 전달\n\n::: {#c64f7cfa .cell execution_count=9}\n``` {.python .cell-code}\ndef identity_function(x):\n    return x\n\nW3 = np.array([[0.1, 0.3], [0.2, 0.4]])\nB3 = np.array([0.1, 0.2])\n\nA3 = np.dot(Z2, W3) + B3\nY = identity_function(A3)\n```\n:::\n\n\n출력층의 활성화 함수는 보통 풀고자 하는 문제의 성질에 맞게 정함\n\n- 회귀: 항등 함수\n- 2클래스 분류: 시그모이드 함수\n- 다중 클래스 분류: 소프트맥스 함수\n\n",
    "supporting": [
      "01_files"
    ],
    "filters": [],
    "includes": {}
  }
}