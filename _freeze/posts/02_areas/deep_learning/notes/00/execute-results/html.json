{
  "hash": "05c15132fe66093fe798ac8bf1a63541",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"퍼셉트론\"\ndate: 2025-03-17\ncategories: [\"deep learning\"]\n---\n\n\n\n\n![](/img/stat-thumb.jpg){.post-thumbnail}\n\n## 퍼셉트론이란\n\n다수의 신호를 입력으로 받아 하나의 신호를 출력하는 것\n\n$$\ny = \\begin{cases} 0 & (w_1x_1 + w_2x_2 \\leq \\theta) \\\\ 1 & (w_1x_1 + w_2x_2 > \\theta) \\end{cases}\n$$\n\n## 논리 회로\n\n파라미터 $(w_1, w_2, θ)$의 값을 조정하여 AND, OR, NAND 게이트를 구현할 수 있다.\n\n머신 러닝의 목적은, 기계가 알아서 파라미터의 값을 적절히 조정하는 것이다.\n\n## 퍼셉트론 구현\n\n### AND 게이트\n\n::: {#14b3846d .cell execution_count=1}\n``` {.python .cell-code}\ndef AND(x1, x2):\n    w1, w2, theta = 0.5, 0.5, 0.7 # parameter\n    return (x1*w1 + x2*w2 > theta)\n```\n:::\n\n\n::: {#c8a47281 .cell execution_count=2}\n``` {.python .cell-code}\nprint(AND(0, 0))\nprint(AND(1, 0))\nprint(AND(0, 1))\nprint(AND(1, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nFalse\nFalse\nTrue\n```\n:::\n:::\n\n\n여기서 θ를 $-b$로 치환하고 식을 다시 정리하면 다음과 같다.\n\n$$\ny = \\begin{cases} 0 & (b + w_1x_1 + w_2x_2 ≤ 0) \\\\ 1 & (b + w_1x_1 + w_2x_2 > 0) \\end{cases}\n$$\n\n이때 $w_1$과 $w_2$(가중치)는 각각의 입력신호가 결과에 주는 영향력을 조절하고, $b$(편향)은 뉴런이 얼마나 쉽게 활성화되는지를 조정한다.\n(가중치 합이 -b를 초과할 때만 뉴런이 활성화된다.)\n\n이제 재구성한 식과, numpy를 이용하여 NAND와 OR 게이트를 구현해보자.\n\n### NAND 게이트\n\n::: {#d9349019 .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\n\ndef NAND(x1, x2):\n  x = np.array([x1, x2])\n  w = np.array([-0.5, -0.5])\n  b = 0.7\n  return (b + np.sum(x * w) > 0)\n```\n:::\n\n\n::: {#ca8ebb2a .cell execution_count=4}\n``` {.python .cell-code}\ndef OR(x1, x2):\n  x = np.array([x1, x2])\n  w = np.array([0.5, 0.5])\n  b = -0.2\n  return (b + np.sum(x * w) > 0)\n```\n:::\n\n\n세 게이트의 차이는 오직 파라미터의 값이다.\n\n## 퍼셉트론의 한계\n\nAND, NAND, OR 게이트는 만들 수 있지만, XOR 게이트는 만들 수 없다.\n다른 게이트들과 다르게 선형적으로 구분이 안되기 때문이다.\n\n하지만 AND NAND OR 게이트를 다음과 같이 배치하면 XOR 게이트를 만들 수 있다.\n\n\n\n\n```{mermaid}\nflowchart LR\n    x1((x1)) --> OR\n    x2((x2)) --> OR\n    x1 --> NAND\n    x2 --> NAND\n    OR[OR 게이트] --> AND\n    NAND[NAND 게이트] --> AND\n    AND[AND 게이트] --> output((XOR 출력))\n```\n\n\n\n(mermaid로는 이렇게 그리는게 최선이다.)\n\n이와 같이 여러 퍼셉트론을 연결한 형태를 다층 퍼센트론이라고 한다.\n\n### XOR 게이트\n\n::: {#5afc6fb8 .cell execution_count=5}\n``` {.python .cell-code}\ndef XOR(x1, x2):\n  s1 = OR(x1, x2)\n  s2 = NAND(x1, x2)\n  return AND(s1, s2)\n```\n:::\n\n\n::: {#211385bc .cell execution_count=6}\n``` {.python .cell-code}\nprint(XOR(0, 0))\nprint(XOR(0, 1))\nprint(XOR(1, 0))\nprint(XOR(1, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nTrue\nTrue\nFalse\n```\n:::\n:::\n\n\n",
    "supporting": [
      "00_files"
    ],
    "filters": [],
    "includes": {}
  }
}