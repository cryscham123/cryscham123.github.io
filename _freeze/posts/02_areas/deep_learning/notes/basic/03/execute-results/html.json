{
  "hash": "d9ecc898771571c3f292d47e4b7ccece",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"오차역전법\"\ndate: 2025-08-01\ncategories: [\"deep learning\"]\n---\n\n\n\n\n![](/img/stat-thumb.jpg){.post-thumbnail}\n\n## 계산 그래프\n\n### 특징\n\n- 국소적 계산: 자신과 관계된 정보만 결과로 출력\n- 중간 결과를 모두 저장할 수 있다.\n- 역전파를 통해 특정 단계에서의 최정 결과에 대한 미분을 효율적으로 계산할 수 있다.\n\n### 예시 - 순전파\n\n- 철수는 슈퍼에서 사과를 2개 귤을 3개 샀다. 사과는 1개 100원, 귤은 1개 150원이다. 소비세가 10%일 때 지불 금액은?\n\n\n\n\n```{mermaid}\nflowchart LR\n    apple_num((사과 갯수)) -- 2 --> apple_x\n    apple_price((사과 가격)) -- 100 --> apple_x\n    orange_num((귤 갯수)) -- 3 --> orange_x\n    orange_price((귤 가격)) -- 150 --> orange_x\n    tax((소비세)) -- 1.1 --> total_x\n    apple_x[x] -- 200 --> fruit_plus\n    orange_x[x] -- 450 --> fruit_plus\n    fruit_plus(+) -- 650 --> total_x\n    total_x[x] -- 715 --> output((지불 금액))\n```\n\n\n\n\n## 오차역전법\n\n- 연쇄법칙을 생각하면 됨.\n\n### 덧셈 노드 역전파\n\n- 덧셈 노드의 역전파는 입력값을 그대로 전달한다.\n\n### 곱셈 노드 역전파\n\n- 곱셈 노드의 역전파는 입력값을 그대로 전달하되, 다른 입력값을 곱해준다.\n\n### 예시 - 역전파\n\n- 철수는 슈퍼에서 사과를 2개 귤을 3개 샀다. 사과는 1개 100원, 귤은 1개 150원이다. 소비세가 10%일 때 지불 금액은?\n\n\n\n\n```{mermaid}\nflowchart LR\n    apple_num((사과 갯수)) -- 2 --> apple_x\n    apple_price((사과 가격)) -- 100 --> apple_x\n    tax((소비세)) -- 1.1 --> total_x\n    apple_x[x] -- 200 --> total_x\n    total_x[x] -- 220 --> output((지불 금액))\n\n    apple_x -. 110 .-> apple_num\n    apple_x -. 2.2 .-> apple_price\n    total_x -. 200 .-> tax\n    total_x -. 1.1 .-> apple_x\n    output -. 1 .-> total_x\n```\n\n\n\n\n## python 구현\n\n::: {#f5d5a910 .cell execution_count=1}\n``` {.python .cell-code}\nclass MulLayer:\n\n    def __init__(self):\n        self.x = None\n        self.y = None\n\n    def forward(self, x, y):\n        self.x = x\n        self.y = y\n        out = x * y\n\n        return out\n\n    def backward(self, dout):\n        dx = dout * self.y\n        dy = dout * self.x\n\n        return dx, dy\n```\n:::\n\n\n::: {#16beaaf6 .cell execution_count=2}\n``` {.python .cell-code}\nclass AddLayer:\n    def __init__(self):\n        pass\n\n    def forward(self, x, y):\n        out = x + y\n        return out\n\n    def backward(self, dout):\n        dx = dout * 1\n        dy = dout * 1\n        return dx, dy\n```\n:::\n\n\n## 활성화 함수 계층\n\n### ReLU\n\n- 입력이 0보다 크면 그대로, 작으면 0\n\n::: {#12f87bd2 .cell execution_count=3}\n``` {.python .cell-code}\nclass Relu:\n    def __init__(self):\n        self.mask = None\n\n    def forward(self, x):\n        self.mask = (x <= 0)\n        out = x.copy()\n        out[self.mask] = 0\n        return out\n\n    def backward(self, dout):\n        dx = dout.copy()\n        dx[self.mask] = 0\n        return dx\n```\n:::\n\n\n### Sigmoid\n\n- $\\frac{hL}{hy}y^2exp(-x) = \\frac{hL}{hy}y(1-y)$ (계산 생략)\n\n::: {#05b94a8c .cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\n\nclass Sigmoid:\n    def __init__(self):\n        self.out = None\n\n    def forward(self, x):\n        out = 1 / (1 + np.exp(-x))\n        self.out = out\n\n        return out\n\n    def backward(self, dout):\n        dx = dout * (1 - self.out) * self.out\n        return dx\n```\n:::\n\n\n### Affine\n\n- WX + B 계산 node\n- $\\frac{dL}{dX} = \\frac{dL}{dY} ⋅ W^T$\n- $\\frac{dL}{dW} = X^T ⋅ \\frac{dL}{dY}$\n- $\\frac{dL}{dB} = \\sum \\frac{dL}{dY}$\n\n::: {#9279088e .cell execution_count=5}\n``` {.python .cell-code}\nclass Affine:\n    def __init__(self, W, b):\n        self.W = W\n        self.b = b\n        self.x = None\n        self.dW = None\n        self.db = None\n\n    def forward(self, x):\n        self.x = x\n        out = np.dot(x, self.W) + self.b\n        return out\n\n    def backward(self, dout):\n        dx = np.dot(dout, self.W.T)\n        self.dW = np.dot(self.x.T, dout)\n        self.db = np.sum(dout, axis=0)\n\n        return dx\n```\n:::\n\n\n### Softmax\n\n::: {#da024a91 .cell execution_count=6}\n``` {.python .cell-code}\nclass SoftmaxWithLoss:\n    def __init__(self):\n        self.loss = None\n        self.y = None\n        self.t = None\n\n    def forward(self, x, t):\n      self.t = t\n      self.y = softmax(x)\n      self.loss = cross_entropy_error(self.y, self.t)\n\n      return self.loss\n\n    def backward(self, dout=1):\n        batch_size = self.t.shape[0]\n        dx = (self.y - self.t) / batch_size\n\n        return dx\n```\n:::\n\n\n## 오차역전법 신경망\n\n::: {#82dbddd1 .cell execution_count=7}\n``` {.python .cell-code}\nfrom dl_common.layers import *\nfrom dl_common.gradient import numerical_gradient\nfrom collections import OrderedDict\n\nclass TwoLayerNet:\n    def __init__(self, input_size, hidden_size, output_size, weight_init_std=0.01):\n        self.params = {}\n        self.params['W1'] = weight_init_std * np.random.randn(input_size, hidden_size)\n        self.params['b1'] = np.zeros(hidden_size)\n        self.params['W2'] =  weight_init_std * np.random.randn(hidden_size, output_size)\n        self.params['b1'] = np.zeros(output_size)\n      \n        self.layers = OrderedDict()\n        self.layers['Affine1'] = Affine(self.params['W1'], self.params['b1'])\n        self.layers['Relu1'] = Relu()\n        self.layers['Affine2'] = Affine(self.params['W2'], self.params['b2'])\n        self.last_layer = SoftmaxWithLoss()\n\n    def predict(self, x):\n        for layer in self.layers.values():\n            x = layer.forward(x)\n        return x\n\n    def loss(self, x , t):\n        y = self.predict(x)\n        return self.last_layer.forward(y, t)\n\n    def auuracy(self, x, t):\n        y = self.predict(x)\n        y = np.argmax(y, axis=1)\n        if t.ndim != 1:\n            t = np.argmax(t, axis=1)\n        acc = np.mean(y == t)\n\n        return acc\n\n    def gradient(self, x, t):\n        self.loss(x, t)\n\n        dout = 1\n        dout = self.last_layer.backward(dout)\n        \n        layers = list(self.layers.values())\n        layers.reverse()\n        for layer in layers:\n            dout = layer.backward(dout)\n        \n        grads = {}\n\n        grads['W1'] = numerical_gradient(loss_W, self.params['W1'])\n        grads['b1'] = numerical_gradient(loss_W, self.params['b1'])\n        grads['W2'] = numerical_gradient(loss_W, self.params['W2'])\n        grads['b2'] = numerical_gradient(loss_W, self.params['b2'])\n        \n        return grads\n```\n:::\n\n\n::: {#adecdf93 .cell execution_count=8}\n``` {.python .cell-code}\nfrom dl_dataset.mnist import load_mnist\n\n(x_train, t_train), (x_test, t_test) = load_mnist(normalize=True, one_hot_label=True)\n\ntrain_loss_list = []\ntrain_acc_list = []\ntest_acc_list = []\n\niters_num = 10000\ntrain_size = x_train.shape[0]\nbatch_size = 100\nlearning_rate = 0.1\nnetwork = TwoLayerNet(input_size=784, hidden_size=50, output_size=10)\niter_per_epoch = max(train_size / batch_size, 1)\n\nfor i in range(iters_num):\n    batch_mask = np.random.choice(train_size, batch_size)\n    x_batch = x_train[batch_mask]\n    t_batch = t_train[batch_mask]\n    grads = network.gradient(x_batch, t_batch)\n    for key in ('W1', 'b1', 'W2', 'b2'):\n        network.params[key] -= learning_rate * grads[key]\n    loss = network.loss(x_batch, t_batch)\n    train_loss_list.append(loss)\n\n    if i % iter_per_epoch == 0:\n        train_acc = network.accuracy(x_train, t_train)\n        test_acc = network.accuracy(x_test, t_test)\n        train_acc_list.append(train_acc)\n        test_acc_list.append(test_acc)\n```\n:::\n\n\n",
    "supporting": [
      "03_files"
    ],
    "filters": [],
    "includes": {}
  }
}