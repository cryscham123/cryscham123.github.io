{
  "hash": "49072557a114f815762166d0244da8ba",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Integer Programming\"\ndate: 2024-12-31\ncategories: [\"Operational Research\", \"1차\"]\ndirectories: [\"OR_예습\", \"phd_3_1\"]\n---\n\n\n\n\n![](/img/human-thumb.jpg){.post-thumbnail}\n\nall or nothing problem에서 사용  \nex) knapsack problem → 아이템을 0.8개 넣을 수 없다\n\n## Requirements on selecting variables\n\n1. **At Least**\n\n   at least `one` of variables among items 1, 3, 4:\n\n   $x_1 + x_3 + x_4 ≥ 1$\n\n2. **At Most**\n\n   at most `two` of variables among items 1, 3, 4:\n\n   $x_1 + x_3 + x_4 ≤ 2$\n\n3. **Or**\n\n    select variable 1 or 2:\n  \n    $x_1 + x_2 ≥ 1$\n\n    select 2 otherwise item 3 and 4 together:\n\n    $2x_2 + x_3 + x_4 ≥ 2$\n\n4. **If-else**\n  \n      if variable 1 is selected, then variable 2 is also selected:\n  \n      $x_1 ≤ x_2$\n  \n      if variable 1 is selected, do not select item 3 and 4:\n  \n      $2(1 - x_1) ≥ x_3 + x_4$\n\n## At least/most some constraints\n\nconstraints를 유연하게 선택하는 방법\n\n$g_1(x) ≤ b_1$과 $g_2(x) ≥ b_2$를 둘 다 만족하는 경우를 표현하려면 union으로 표현할 수 있다.\n\n이는 linear program에 적합하지 않기 때문에 variable로 표현한다.\n\n$$z = \\begin{cases}\n0 & \\text{if } g_1(x) ≤ b_1 \\\\\n1 & \\text{if } g_2(x) ≤ b_2\n\\end{cases}$$\n\n이는 아래의 수식으로 표현할 수 있다\n\n$$\\begin{align}\n&g_1(x) - b_1 ≤ M_1z \\\\\n&g_2(x) - b_2 ≤ M_2(1 - z)\n\\end{align}$$\n\n이때$M_1$과 $M_2$는 충분히 큰 상수이다.\n\n## 일반적인 예시\n\nFacility location problem\n\n1. where to open convenience stores?\n2. where to build warehouses or distribution centers?\n3. where to build factories?\n4. where to build power stations, fire stations, or police stations?\n\n→ where to locate scarce resource?\n\ndemoand nodes potential locations\n\n1. set covering problem\n2. maximum covering problem\n3. fixed charge location problem\n\n::: {#ef9b4962 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nfrom scipy.optimize import minimize\n\n# 예시 데이터: 자산 수익률과 공분산 행렬\nreturns = np.array([0.12, 0.18, 0.15])  # 자산 수익률\ncov_matrix = np.array([[0.1, 0.02, 0.04],\n                       [0.02, 0.08, 0.03],\n                       [0.04, 0.03, 0.09]])  # 공분산 행렬\n\n# 목적 함수: 포트폴리오 분산 최소화\ndef portfolio_variance(weights):\n    return np.dot(weights.T, np.dot(cov_matrix, weights))\n\n# 제약 조건: 투자 비중의 합은 1\nconstraints = ({'type': 'eq', 'fun': lambda weights: np.sum(weights) - 1})\n\n# 초기값: 균등 가중치\ninit_weights = np.array([1/3, 1/3, 1/3])\n\n# 최적화 실행\nresult = minimize(portfolio_variance, init_weights, method='SLSQP', constraints=constraints)\n\nprint(\"최적 투자 비중:\", result.x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n최적 투자 비중: [0.29522781 0.43811726 0.26665493]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "2_files"
    ],
    "filters": [],
    "includes": {}
  }
}