{
  "hash": "1dfbecb965d5578b5853308fbee402e2",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"공산과 가산\"\ndate: 2025-06-20\ncategories: [\"확률 통계\"]\n---\n\n\n\n\n![](/img/stat-thumb.jpg){.post-thumbnail}\n\n## 공산\n\n::: {#6f1746c8 .cell execution_count=1}\n``` {.python .cell-code}\ndef odds(p):\n  return p / (1 - p)\n\ndef prob(o):\n  return o / (1 + o)\n\ndef prob2(a, b):\n  return a / (a + b)\n\nodds(0.6)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1.4999999999999998\n```\n:::\n:::\n\n\n## 베이즈 규칙\n\n$odds(A|D) = odds(A) \\cdot \\frac{P(D|A)}{P(D|B)}$\n\n::: {#1abb2e92 .cell execution_count=2}\n``` {.python .cell-code}\nprior_odds = 1\nlikelihood_ratio = (3/4) / (1/2)\npost_odds = prior_odds * likelihood_ratio\npost_odds\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n1.5\n```\n:::\n:::\n\n\n::: {#7a04e50e .cell execution_count=3}\n``` {.python .cell-code}\nprob(post_odds)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n0.6\n```\n:::\n:::\n\n\n::: {#6d5e3c07 .cell execution_count=4}\n``` {.python .cell-code}\nlikelihood_ratio = (1/4) / (1/2)\npost_odds *= likelihood_ratio\npost_odds\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n0.75\n```\n:::\n:::\n\n\n::: {#d0d4ad19 .cell execution_count=5}\n``` {.python .cell-code}\nprob(post_odds)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n0.42857142857142855\n```\n:::\n:::\n\n\n## 올리버의 혈액형\n\n- 범죄 현장에서 두 사람의 혈흔을 발견했다.\n- 발견된 혈흔은 O형과 AB형이다.\n- 해당 지역에서 O형의 비율은 0.6, AB형의 비율은 0.01이다.\n- 올리버는 O형이다.\n- 범죄 현장의 혈흔(데이터)이 올리버가 범인 중 한 명이라는 질문(가정)에 대한 증거가 될 수 있는가\n\n$odds(A|D) = odds(A) \\cdot \\frac{P(D|A)}{P(D|B)}$\n$→ \\frac{odds(A|D)}{odds(A)} = \\frac{P(D|A)}{P(D|B)}$\n\n- 베이즈 요인 > 1: A의 가정 하에 존재하는게 더 가깝다.\n- 베이즈 요인 < 1: B의 가정 하에 존재하는게 더 가깝다.\n- 베이즈 요인 == 1: 양쪽 가설 하에서 동일한 가능성을 가진다.\n\n::: {#28080cfa .cell execution_count=6}\n``` {.python .cell-code}\nlike1 = 0.01 # oliver가 혈흔을 남긴 경우\nlike2 = 2 * 0.6 * 0.01 # oliver가 혈흔을 남기지 않은 경우\n\nlikelihood_ratio = like1 / like2\nlikelihood_ratio\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n0.8333333333333334\n```\n:::\n:::\n\n\n- 가능도비가 1보다 낮기 때문에, oliver가 혈흔을 남기지 않은 쪽에 더 가깝다.\n\n::: {#edbd8460 .cell execution_count=7}\n``` {.python .cell-code}\npost_odds = 1 * like1 / like2\nprob(post_odds)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n0.45454545454545453\n```\n:::\n:::\n\n\n## 글루텐 민감도\n\n- 글루텐에 민감한 사람은 블라이든 검사에서 글루텐 밀가루를 정확히 식별할 확률이 95%다\n- 글루텐에 민감하지 않은 사람이 우연히 글루텐 밀가루를 식별할 확률은 40%다.\n\n::: {#8c71cec7 .cell execution_count=8}\n``` {.python .cell-code}\nn = 35\nnum_sensitive = 10\nnum_insensitive = n - num_sensitive\n```\n:::\n\n\n::: {#0c9be6a1 .cell execution_count=9}\n``` {.python .cell-code}\nfrom scipy.stats import binom\nfrom empiricaldist import Pmf\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef make_binomial(n, p):\n  ks = np.arange(n+1)\n  ps = binom.pmf(ks, n, p)\n  return Pmf(ps, ks)\n\ndist_sensitive = make_binomial(num_sensitive, 0.95)\ndist_insensitive = make_binomial(num_insensitive, 0.40)\n\ndist_total = Pmf.add_dist(dist_sensitive, dist_insensitive)\n\ndist_sensitive.plot(label='sensitive', ls=':')\ndist_insensitive.plot(label='insensitive', ls='--')\ndist_total.plot(label='total')\nplt.legend()\n```\n\n::: {.cell-output .cell-output-display}\n![](05_files/figure-html/cell-10-output-1.png){width=571 height=411}\n:::\n:::\n\n\n### 역산\n\n- 35명의 피험자중 12명이 글루텐이 있다고 했을 때, 글루텐에 민감한 사람의 비율은?\n\n::: {#097722f7 .cell execution_count=10}\n``` {.python .cell-code}\nimport pandas as pd\n\ntable = pd.DataFrame()\nfor num_sensitive in range(0, n+1):\n  num_insensitive = n - num_sensitive\n  dist_sensitive = make_binomial(num_sensitive, 0.95)\n  dist_insensitive = make_binomial(num_insensitive, 0.40)\n  dist_total = Pmf.add_dist(dist_sensitive, dist_insensitive)\n  table[num_sensitive] = dist_total\n\nfor dist in table:\n  table[dist].plot(label=f'num_sensitive = {dist}')\n```\n\n::: {.cell-output .cell-output-display}\n![](05_files/figure-html/cell-11-output-1.png){width=579 height=411}\n:::\n:::\n\n\n::: {#8670dd4f .cell execution_count=11}\n``` {.python .cell-code}\nlikelihood1 = table.loc[12]\nhypos = np.arange(n+1)\nprior = Pmf(1, hypos)\n\nposterior1 = prior * likelihood1\nposterior1.normalize()\n\nlikelihood2 = table.loc[20]\nposterior2 = prior * likelihood2\nposterior2.normalize()\n\nplt.rcParams['font.family'] = 'Noto Sans KR'\n\nposterior1.plot(label='12개가 정확히 분류한 경우의 사후분포', color='C4')\nposterior2.plot(label='20개가 정확히 분류한 경우의 사후분포', color='C5')\nplt.legend()\n```\n\n::: {.cell-output .cell-output-display}\n![](05_files/figure-html/cell-12-output-1.png){width=575 height=412}\n:::\n:::\n\n\n::: {#4043584b .cell execution_count=12}\n``` {.python .cell-code}\nprint(f'12명이 정확히 분류했을 때 글루텐 민감한 사람은 {posterior1.max_prob()}명, 20명이 정확히 분류했을 때 {posterior2.max_prob()}명일 확률이 높음')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n12명이 정확히 분류했을 때 글루텐 민감한 사람은 0명, 20명이 정확히 분류했을 때 11명일 확률이 높음\n```\n:::\n:::\n\n\n## 연습문제\n\n### 6-1\n\n::: {#06640f75 .cell execution_count=13}\n``` {.python .cell-code}\nfor trust in [0.9, 0.5, 0.1]:\n  prior_odds = odds(trust)\n  post_odds =  prior_odds * likelihood_ratio\n  print(f'{trust}, {prior_odds}: {prob(post_odds)}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.9, 9.000000000000002: 0.8823529411764706\n0.5, 1.0: 0.45454545454545453\n0.1, 0.11111111111111112: 0.08474576271186442\n```\n:::\n:::\n\n\n### 6-2\n\n::: {#5f080c0f .cell execution_count=14}\n``` {.python .cell-code}\nprior_odds = odds(1/3)\npost_odds = prior_odds * 2\npost_odds *= 1.25\n\nprob(post_odds)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n0.5555555555555555\n```\n:::\n:::\n\n\n### 6-3\n\n::: {#6eca7455 .cell execution_count=15}\n``` {.python .cell-code}\nprior_odds = odds(1/10)\npost_odds = prior_odds * (2 ** 3)\n\nprob(post_odds)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n0.4705882352941177\n```\n:::\n:::\n\n\n- 베이즈 방법을 이용하나 빈도주의적 방법을 이용하나, 확률을 구하는 문제에 있어서는 차이가 없다.\n- 하지만 통계적 추론 방법을 선택하는데 있어서는 차이가 있다.\n\n### 6-4\n\n::: {#5e6d0941 .cell execution_count=16}\n``` {.python .cell-code}\nprior_odds = odds(14/100)\npost_odds = prior_odds * 25\n\nprob(post_odds)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n0.8027522935779816\n```\n:::\n:::\n\n\n### 6-5\n\n::: {#f41d37d3 .cell execution_count=17}\n``` {.python .cell-code}\ndice6 = Pmf.from_seq(np.arange(1, 7))\ngoblin_health = dice6.add_dist(dice6)\nremaining_health = Pmf.sub_dist(goblin_health, 3)\nattack_damage = dice6\n\ndefeat_probability = 0\nfor damage, damage_prob in attack_damage.items():\n    for remaining, remaining_prob in remaining_health.items():\n        if remaining > 0 and damage > remaining:\n            defeat_probability += damage_prob * remaining_prob\n\nprint(f\"\\n고블린을 물리칠 확률: {defeat_probability:.3f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n고블린을 물리칠 확률: 0.292\n```\n:::\n:::\n\n\n### 6-6\n\n::: {#620960eb .cell execution_count=18}\n``` {.python .cell-code}\nimport numpy as np\n\nhypos = [6, 8, 12]\npmf = Pmf(1/3, hypos)\ndice = [Pmf([1/6] * 6, np.arange(1, 7)),\n        Pmf([1/8] * 8, np.arange(1, 9)),\n        Pmf([1/12] * 12, np.arange(1, 13))]\nlike = [d.mul_dist(d) for d in dice]\ndf = pd.DataFrame(like).fillna(0).transpose()\ndf *= pmf.ps\ndf[1][12]\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n0.020833333333333332\n```\n:::\n:::\n\n\n### 6-7\n\n::: {#d99ce93a .cell execution_count=19}\n``` {.python .cell-code}\npmf = Pmf(1, ['long', 'zost', 'bell'])\npmf.normalize()\ndice = Pmf([1/3] * 3, np.arange(0, 3))\nlike = [dice.add_dist(dice).add_dist(dice).add_dist(dice).add_dist(dice),\n        dice.add_dist(dice).add_dist(dice).add_dist(dice),\n        dice.add_dist(dice).add_dist(dice)]\ndf = pd.DataFrame(like).fillna(0).transpose()\nfor i in [3, 4, 5]:\n  pmf *= np.array(df.loc[i])\n  pmf.normalize()\npmf\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>probs</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>long</th>\n      <td>0.235762</td>\n    </tr>\n    <tr>\n      <th>zost</th>\n      <td>0.449704</td>\n    </tr>\n    <tr>\n      <th>bell</th>\n      <td>0.314534</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### 6-8\n\n::: {#ea84e92f .cell execution_count=20}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import binom\nfrom empiricaldist import Pmf\n\nn_total = 538\nn_outperform = 312\n\nhypos = np.arange(n_total + 1)\nprior = Pmf(1, hypos)\nprior.normalize()\n\nlikelihoods = np.zeros(prior.shape[0])\nfor n_honest in hypos:\n    n_dishonest = n_total - n_honest\n    honest_dist = make_binomial(n_honest, 0.5)\n    dishonest_dist = make_binomial(n_dishonest, 0.9)\n    total_dist = Pmf.add_dist(honest_dist, dishonest_dist)\n    likelihood = total_dist[n_outperform]\n    likelihoods[n_honest] = likelihood\n\nposterior = prior * likelihoods\nposterior.normalize()\n\nmost_likely_honest = posterior.max_prob()\nposterior_prob = posterior[most_likely_honest]\n\nprint(f\"가장 가능성이 높은 정직한 의원 수: {most_likely_honest}명\")\nprint(f\"해당 확률: {posterior_prob:.4f}\")\n\n# 사후분포 시각화\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(12, 6))\nposterior.plot()\nplt.xlabel('정직한 의원 수')\nplt.ylabel('확률')\nplt.title('정직한 의원 수에 대한 사후분포')\nplt.axvline(most_likely_honest, color='red', linestyle='--', \n           label=f'최빈값: {most_likely_honest}명')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n\n# 95% 신용구간\ncredible_interval = posterior.credible_interval(0.95)\nprint(f\"95% 신용구간: {credible_interval[0]}명 - {credible_interval[1]}명\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n가장 가능성이 높은 정직한 의원 수: 430명\n해당 확률: 0.0147\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](05_files/figure-html/cell-21-output-2.png){width=974 height=525}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n95% 신용구간: 380.0명 - 486.0명\n```\n:::\n:::\n\n\n",
    "supporting": [
      "05_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}