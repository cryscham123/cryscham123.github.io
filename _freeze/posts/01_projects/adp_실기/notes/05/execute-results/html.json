{
  "hash": "855217cc40767782ac8843df92a18cc5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"분산 분석 템플릿\"\ndate: 2025-10-05\ncategories: [\"데이터 분석\"]\n---\n\n\n\n\n## 가정 검정\n\n![검정 방법 선택 기준](img/2025-09-07-10-39-35.png)\n\n![모수 검정 방법 선택 기준](img/2025-09-07-10-45-15.png)\n\n- 관측치 간에 독립이 아닌 경우(시간: 자기 상관이 존재, 공간: 패널, 계층, ...), 각 케이스에 맞는 모형을 사용해야 함.\n\n### 정규성 검정\n\n- 표본이 정규분포를 따르는지 검정.\n- 따르지 않더라도 중심극한정리에 의해 **표본의 크기가 충분히 크면** 모수 검정을 사용할 수 있다.\n\n- **shapiro wilk 검정**: 표본의 크기가 3-5000개인 데이터에 사용. 동일한 값이 많은 경우 성능이 떨어질 수 있음\n    - H0: 데이터가 정규분포를 따른다.\n    - H1: 데이터가 정규분포를 따르지 않는다.\n- **jarque-Bera**: 대표본에 사용.\n    - H0: 데이터가 정규분포를 따른다.\n    - H1: 데이터가 정규분포를 따르지 않는다.\n- **Q-Q plot**: x축이 이론적 분위수, y축이 표본 분위수\n\n```{.python filename=\"normality test\"}\n#| eval: false\n\nfrom scipy.stats import shapiro, jarque_bera, zscore, probplot\n\ndata = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nstat, p = shapiro(data)\n\nprint(f\"Shapiro-Wilk Test: stat={stat:.3f}, p={p:.3f}\")\n\nstat, p = jarque_bera(data)\nprint(f\"Jarque-Bera Test: stat={stat:.3f}, p={p:.3f}\")\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nzdata = zscore(data)\nfig, ax = plt.subplots(1, 2, figsize=(10, 3))\n\n(osm, odr), (slope, intercept, r)) = probplot(zdata, plot=ax[0])\nax[0].set_title(\"Q-Q Plot\")\n\nsns.histplot(data, kde=True, ax=ax[1])\nax[1].set_title(\"Histogram\")\n\nplt.show()\n```\n\n### 등분산성 검정\n\n- **Barlett 검정**: **정규성을 만족하는 경우에만** 사용 가능\n    - H0: $σ_1^2 = σ_2^2 = ... = σ_k^2$\n    - H1: $σ_i ≠ σ_j$ for some i, j\n- **Levene 검정**: **정규성을 만족하지 않는 경우에도** 사용 가능\n    - H0: $σ_1^2 = σ_2^2 = ... = σ_k^2$\n    - H1: $σ_i ≠ σ_j$ for some i, j\n\n```{.python filename=\"equal variance test\"}\n#| eval: false\n\nfrom scipy.stats import bartlett, levene\n\ngroup1 = [1, 2, 3, 4, 5]\ngroup2 = [2, 3, 4, 5, 6]\ngroup3 = [3, 4, 5, 6, 7]\n\nstat, p = bartlett(group1, group2, group3)\nprint(f\"Bartlett's Test: stat={stat:.3f}, p={p:.3f}\")\n\nstat, p = levene(group1, group2, group3)\nprint(f\"Levene's Test: stat={stat:.3f}, p={p:.3f}\")\n```\n\n## 분산 분석\n\n![](img/2025-10-06-18-54-33.png)\n\n- 정규성을 만족 못할 경우, 서열척도 비모수 검정 사용 가능\n- 코크란 Q 검정: 이항분포를 따르는 반복 측정 자료에 사용\n    - 만약 대응표본이 아닐 경우 (실패, 성공) 변수를 만들어서 독립성 검정 사용\n    - 만약 이항분포가 아닐 경우 프리드만 검정 고려\n- 독립성 검정의 cell의 기대도수가 5 미만인 경우, 피셔의 정확검정 사용\n    - 만약 2x3을 넘어갈 경우 몬테카를로 시뮬레이션 사용(python으로 구현하기 복잡하다.)\n- 크루스칼, 맨휘트니: 동점이 과하게 많을 경우 permutation test, 순열 분산 분석 사용 가능\n    - 하지만 ADP 환경의 scipy에서는 버전이 낮아서 permutation test를 쓸 수 없다.\n\n```{.python filename=\"사후 검정\"}\n#| eval: false\n\nfrom statsmodels.sandbox.stats.multicomp import MultiComparison\nfrom scipy.stats import ttest_ind\n\nmc = MultiComparison(data, groups).allpairtest(ttest_ind, method='bonf')\nprint(mc[0])\n\nmc.plot_simultaneous()\nplt.show()\n```\n\n### 적합성 검정\n\n```{.python filename=\"카이제곱 적합성 검정\"}\n#| eval: false\n\ncount = df_count['count'].value_counts().sort_index()\n\n# 빈도 수가 5 미만인 경우 합침\n\ncount.loc[1] += count.loc[0]\ncount.loc[6] += count.loc[[7, 8]].sum()\ncount.drop([0, 7, 8], inplace=True)\n\n# 모수 추정\nlam = df_count['count'].mean()\npoi = poisson(lam)\n\nn = count.values.sum()\nexp = np.array([(poi.pmf(0) + poi.pmf(1)), \n       *poi.pmf(np.arange(2, 6)), \n       poi.sf(5)]) # 마지막 값은 이상 값으로\nexp *= n\n\nfrom scipy.stats import chisquare\n\n# 추정한 모수 갯수 만큼 자유도 차감\nstat, p = chisquare(count.values, exp, ddof=1)\np\n```\n\n- 연속형\n    - 이표본 검정: 콜모고로프-스미르노프 검정 사용\n    - 일표본 검정:\n        - 정규분포, 지수분포: 앤더슨-달링 검정 사용\n        - 그 외: 몬테카를로 방법 사용\n- 이산형\n    - 이표본: 카이제곱 독립성 검정\n    - 일표본: 카이제곱 동질성 검정\n\n## 다변량 분산분석\n\n### 2-way ANOVA\n\n- 반복이 없는 경우 교효작용 검정은 불가능\n- 정규성, 등분산성 검정은 잔차에 대해 수행\n\n::: {#8492f05c .cell execution_count=1}\n``` {.python .cell-code}\nfrom statsmodels.formula.api import ols\nfrom statsmodels.stats.anova import anova_lm\n\n\nmodel = ols(\"성적~C(성별)+C(교육방법)+C(성별):C(교육방법)\", data=data).fit()\natab = anova_lm(model)\natab\n```\n:::\n\n\n::: {#0b5d2035 .cell execution_count=2}\n``` {.python .cell-code}\nfrom scipy.stats import shapiro\n\nresiduals = model.resid\n\nshapiro_test = shapiro(residuals)\nprint(f\"Shapiro-Wilk Test on Residuals: Statistic={shapiro_test.statistic}, p-value={shapiro_test.pvalue}\")\n```\n:::\n\n\n::: {#ce4dc196 .cell execution_count=3}\n``` {.python .cell-code}\nsns.residplot(x=model.fittedvalues, y=residuals, lowess=True,\n              line_kws={'color': 'red', 'lw': 2})\nplt.show()\n```\n:::\n\n\n- 교효작용이 유의하지 않을 경우 오차항에 pooling을 한다.\n\n::: {#1855b8ec .cell execution_count=4}\n``` {.python .cell-code}\nfrom statsmodels.formula.api import ols\nfrom statsmodels.stats.anova import anova_lm\n\n\nmodel = ols(\"성적~C(성별)+C(교육방법)\", data=tmp).fit()\natab = anova_lm(model)\natab\n```\n:::\n\n\n- main 효과의 사후검정은 anova와 동일\n    - 하지만 interation 효과가 유의할 경우, 주효과는 무의미하다.\n- interaction 효과는 시각적으로 보여주는게 좋다.\n\n::: {#55e1b1ec .cell execution_count=5}\n``` {.python .cell-code}\ngrouped = tmp.groupby(['성별', '교육방법'])['성적'].mean().reset_index()\npivot = grouped.pivot(index='성별', columns='교육방법', values='성적')\npivot.plot(marker='o')\nplt.ylabel('평균 성적')\nplt.title('성별-교육방법 교호작용 효과')\nplt.legend(title='교육방법')\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n- 2way 이상은 해석이 어려워서 잘 사용하지 않는다.\n\n### 반복측정 분산분석\n\n```{.python filename=\"repeated measures anova\"}\nimport pingouin as pg\n\ndf = pd.DataFrame({\n    'subject': [1, 2, 3, 1, 2, 3, 1, 2, 3],\n    'condition': ['T1', 'T1', 'T1', 'T2', 'T2', 'T2', 'T3', 'T3', 'T3'],\n    'score': [80, 78, 85, 82, 80, 86, 88, 83, 90]\n})\n\n# 반복측정 ANOVA 수행 및 구형성 검정, 보정 포함\naov = pg.rm_anova(dv='score', within='condition', subject='subject', data=df, correction=True)\ndisplay(aov)\n```\n\n- sphericity가 true이면 구형성 만족\n- p-unc: 구형성 보정 전 p-value\n- p-GG-corr: Greenhouse-Geisser 보정 후 p-value\n    - 구형성 위반 시 사용\n\n",
    "supporting": [
      "05_files"
    ],
    "filters": [],
    "includes": {}
  }
}