{
  "hash": "3c9bcce5f82156f6bbeef75414f9b931",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"텍스트 분석\"\ndate: 2025-07-30\ncategories: [\"머신 러닝\"]\n---\n\n\n\n\n![](/img/stat-thumb.jpg){.post-thumbnail}\n\n## overview\n\n### NLP vs 텍스트 분석\n\n- NLP(자연어 처리)는 컴퓨터가 인간의 언어를 이해하고 처리하는 기술을 의미\n- 텍스트 분석은 주로 비정형 텍스트 데이터를 머신러닝, 통계 등의 방법으로 예측 분석이나 유용한 정보를 추출하는 데 중점을 둔다.\n\n### 종류\n\n- 텍스트 분류: 문서가 특정 분류 또는 카테고리에 속하는 것을 예측 (연예 / 정치 / 스포츠 같은 카테고리 분류 혹은 스팸 메일 검출). 지도 학습\n- 감성 분석: 텍스트에서 주관적 요소를 분석하는 기법. 지도 혹은 비지도.\n- 텍스트 요약: 텍스트 내에서 주제나 중심 사상을 추출\n- 텍스트 군집화: 비슷한 유형의 문서를 군집화 하는 것. 비지도 학습\n\n## 프로세스\n\n1. 텍스트 전처리: 대 / 소문자 변경, 특수 문자 제거, 토큰화, 불용어 제거, 어근 추출 등의 정규화 작업\n2. 피처 벡터화 / 추출: 텍스트에서 피처를 추출하고 벡터 값을 할당. BOW와 Word2Vec이 대표적\n3. ML 모델 수립 및 학습 / 예측 / 평가\n\n## 전처리\n\n- 클렌징: 문자, 기호 등을 사전에 제거\n- 토큰화\n  - 문장 토큰화: 마침표, 개행문자 등을 기준으로 문장을 분리. 각 문장이 가지는 의미가 중요한 경우 사용.\n  - 단어 토큰화: 공백, 콤마, 마침표, 개행문자 등으로 단어를 분리.\n      - n-gram: 단어의 연속된 n개를 묶어서 하나의 단위로 처리하는 방법. 문장이 가지는 의미를 조금이라도 보존할 수 있다.\n\n::: {#63c1ee71 .cell execution_count=1}\n``` {.python .cell-code}\nfrom nltk import sent_tokenize\nimport nltk\nnltk.download('punkt') # 문장을 분리하는 마침표, 개행문자 등의 데이터 셋 다운로드\nnltk.download('punkt_tab')\n\ntext_sample = \"The Matrix is everywhere its all around us, here even in this room. You can see it when you look out your window or when you turn on your television. You can feel it when you go to work, when you go to church, when you pay your taxes.\"\nsentences = sent_tokenize(text_sample)\nprint(sentences)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['The Matrix is everywhere its all around us, here even in this room.', 'You can see it when you look out your window or when you turn on your television.', 'You can feel it when you go to work, when you go to church, when you pay your taxes.']\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n[nltk_data] Downloading package punkt to\n[nltk_data]     /home/cryscham123/nltk_data...\n[nltk_data]   Package punkt is already up-to-date!\n[nltk_data] Downloading package punkt_tab to\n[nltk_data]     /home/cryscham123/nltk_data...\n[nltk_data]   Package punkt_tab is already up-to-date!\n```\n:::\n:::\n\n\n::: {#6b8b73f5 .cell execution_count=2}\n``` {.python .cell-code}\nfrom nltk import word_tokenize\n\nsentence = \"The Matrix is everywhere its all around us, here even in this room.\"\nwords = word_tokenize(sentence)\nprint(words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['The', 'Matrix', 'is', 'everywhere', 'its', 'all', 'around', 'us', ',', 'here', 'even', 'in', 'this', 'room', '.']\n```\n:::\n:::\n\n\n::: {#7f605e1a .cell execution_count=3}\n``` {.python .cell-code}\ndef tokenize_text(text):\n    sentences = sent_tokenize(text)\n    words = [word_tokenize(sentence) for sentence in sentences]\n\n    return words\n\nword_tokens = tokenize_text(text_sample)\nword_tokens\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n[['The',\n  'Matrix',\n  'is',\n  'everywhere',\n  'its',\n  'all',\n  'around',\n  'us',\n  ',',\n  'here',\n  'even',\n  'in',\n  'this',\n  'room',\n  '.'],\n ['You',\n  'can',\n  'see',\n  'it',\n  'when',\n  'you',\n  'look',\n  'out',\n  'your',\n  'window',\n  'or',\n  'when',\n  'you',\n  'turn',\n  'on',\n  'your',\n  'television',\n  '.'],\n ['You',\n  'can',\n  'feel',\n  'it',\n  'when',\n  'you',\n  'go',\n  'to',\n  'work',\n  ',',\n  'when',\n  'you',\n  'go',\n  'to',\n  'church',\n  ',',\n  'when',\n  'you',\n  'pay',\n  'your',\n  'taxes',\n  '.']]\n```\n:::\n:::\n\n\n- stopword 제거: 분석에 필요하지 않은 단어를 제거하는 작업. 예) 관사, 전치사, 접속사 등\n\n::: {#198f8e8c .cell execution_count=4}\n``` {.python .cell-code}\nfrom nltk.corpus import stopwords\nnltk.download('stopwords')  # stopwords 데이터 셋 다운로드\n\nstopwords.words('english')[:20]\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n[nltk_data] Downloading package stopwords to\n[nltk_data]     /home/cryscham123/nltk_data...\n[nltk_data]   Package stopwords is already up-to-date!\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n['a',\n 'about',\n 'above',\n 'after',\n 'again',\n 'against',\n 'ain',\n 'all',\n 'am',\n 'an',\n 'and',\n 'any',\n 'are',\n 'aren',\n \"aren't\",\n 'as',\n 'at',\n 'be',\n 'because',\n 'been']\n```\n:::\n:::\n\n\n::: {#88ec22e1 .cell execution_count=5}\n``` {.python .cell-code}\nsw = stopwords.words('english')\nall_tokens = []\nfor sentence in word_tokens:\n    filtered_words = []\n    for word in sentence:\n        word = word.lower()\n        if word not in sw:\n            filtered_words.append(word)\n    all_tokens.append(filtered_words)\nprint(all_tokens)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[['matrix', 'everywhere', 'around', 'us', ',', 'even', 'room', '.'], ['see', 'look', 'window', 'turn', 'television', '.'], ['feel', 'go', 'work', ',', 'go', 'church', ',', 'pay', 'taxes', '.']]\n```\n:::\n:::\n\n\n- stemming, lemmatization: 문법적 또는 의미적으로 변화하는 단어의 원형을 찾는 것\n    - stemming이 더 단순하고 빠르지만 lemmatization 이 더 저오학함\n\n::: {#dab74859 .cell execution_count=6}\n``` {.python .cell-code}\nfrom nltk.stem import LancasterStemmer\n\nstemmer = LancasterStemmer()\n\nprint(stemmer.stem('working'), stemmer.stem('works'), stemmer.stem('worked'))\nprint(stemmer.stem('amusing'), stemmer.stem('amuses'), stemmer.stem('amused'))\nprint(stemmer.stem('happier'), stemmer.stem('happiest'))\nprint(stemmer.stem('fancier'), stemmer.stem('fanciest'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwork work work\namus amus amus\nhappy happiest\nfant fanciest\n```\n:::\n:::\n\n\n::: {#96465f65 .cell execution_count=7}\n``` {.python .cell-code}\nfrom nltk.stem import WordNetLemmatizer\nimport nltk\nnltk.download('wordnet')\n\nlemma = WordNetLemmatizer()\n\nprint(lemma.lemmatize('amusing', 'v'), lemma.lemmatize('amuses', 'v'), lemma.lemmatize('amused', 'v'))\nprint(lemma.lemmatize('happier', 'a'), lemma.lemmatize('happiest', 'a'))\nprint(lemma.lemmatize('fancier', 'a'), lemma.lemmatize('fanciest', 'a'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\namuse amuse amuse\nhappy happy\nfancy fancy\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n[nltk_data] Downloading package wordnet to\n[nltk_data]     /home/cryscham123/nltk_data...\n[nltk_data]   Package wordnet is already up-to-date!\n```\n:::\n:::\n\n\n## BOW\n\n- 문서가 가지는 모든 단어를 문맥이나 순서를 무시하고 빈도 값을 부여해 피처 값을 추출하는 모델\n- count 기반 벡터화: 빈도가 높을수록 중요한 단어로 인식\n- TF-IDF(term frequency - inverse document frequency) 기반 벡터화: 빈도가 높을수록 좋으나, 모든 문서에서 전반적으로 나타나는 단어에 대해서는 패털티를 줌\n    - $TF_i * log\\frac{N}{DF_i}$\n      - $TF_i$: 개별 문서에서의 단어 i 빈도\n      - $DF_i$: 단어 i를 가지고 있는 문서 개수\n      - N: 전체 문서 개수\n- 희소행렬 문제: 불필요한 0 값이 많아지는 문제\n    - COO\n    - CSR\n    - 혹은 희소행렬을 잘 처리하는 알고리즘: 로지스틱 회귀, 선형 svm, 나이브 베이즈 등\n\n### COO\n\n- 0이 아닌 데이터만 별도의 array에 저장.\n\n::: {#aab7eb13 .cell execution_count=8}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy import sparse\n\ndense = np.array([[3, 0, 1], [0, 2, 0]])\ndata = np.array([3, 1, 2])\nrow_pos = np.array([0, 0, 1])\ncol_pos = np.array([0, 2, 1])\nsparse_coo = sparse.coo_matrix((data, (row_pos, col_pos)))\nsparse_coo\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n<COOrdinate sparse matrix of dtype 'int64'\n\twith 3 stored elements and shape (2, 3)>\n```\n:::\n:::\n\n\n::: {#920b655f .cell execution_count=9}\n``` {.python .cell-code}\nsparse_coo.toarray()\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\narray([[3, 0, 1],\n       [0, 2, 0]])\n```\n:::\n:::\n\n\n### CSR\n\n- COO + 시작위치만 기록하는 방법\n\n::: {#29fe3804 .cell execution_count=10}\n``` {.python .cell-code}\nfrom scipy import sparse\n\ndense2 = np.array([[0, 0, 1, 0, 0, 5],\n                   [1, 4, 0, 3, 2, 5],\n                   [0, 6, 0, 3, 0, 0],\n                   [2, 0, 0, 0, 0, 0],\n                   [0, 0, 0, 7, 0, 8],\n                   [1, 0, 0, 0, 0, 0]])\ndata2 = np.array([1, 5, 1, 4, 3, 2, 5, 6, 3, 2, 7, 8, 1])\nrow_pos = np.array([0, 0, 1, 1, 1, 1, 1, 2, 2, 3, 4, 4, 5])\ncol_pos = np.array([2, 5, 0, 1, 3, 4, 5, 1, 3, 0, 3, 5, 0])\nrow_pos_ind = np.array([0, 2, 7, 9, 10, 12, 13])\n\nsparse_csr = sparse.csr_matrix((data2, col_pos, row_pos_ind))\nsparse_csr.toarray()\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\narray([[0, 0, 1, 0, 0, 5],\n       [1, 4, 0, 3, 2, 5],\n       [0, 6, 0, 3, 0, 0],\n       [2, 0, 0, 0, 0, 0],\n       [0, 0, 0, 7, 0, 8],\n       [1, 0, 0, 0, 0, 0]])\n```\n:::\n:::\n\n\n::: {#e6d22228 .cell execution_count=11}\n``` {.python .cell-code}\nsparse_csr = sparse.csr_matrix(dense2)\nsparse_csr.toarray()\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\narray([[0, 0, 1, 0, 0, 5],\n       [1, 4, 0, 3, 2, 5],\n       [0, 6, 0, 3, 0, 0],\n       [2, 0, 0, 0, 0, 0],\n       [0, 0, 0, 7, 0, 8],\n       [1, 0, 0, 0, 0, 0]])\n```\n:::\n:::\n\n\n",
    "supporting": [
      "07_files"
    ],
    "filters": [],
    "includes": {}
  }
}