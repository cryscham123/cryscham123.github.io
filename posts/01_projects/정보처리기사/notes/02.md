---
title: "소프트웨어 설계 - 어플리케이션 설계"
date: 2026-01-14
categories: ["정보처리기사"]
---

![](/img/stat-thumb.jpg){.post-thumbnail}

## 소프트웨어 아키텍처

### 기본 원리

- 모듈화
- 추상화: `제어`, `과정`, `자료(데이터)` 추상화가 있다.
- 단계적 분해
- 정보 은닉

### 소프트웨어 아키텍처의 품질 속성

- 시스템 측면
- 비즈니스 측면
- 아키텍처 측면: 개념적 무결성, 정확성, 완결성, 구축 가능성 등

### 설계 과정

1. 설계 목표 설정
    - 협약에 의한 설계: 컴포넌트를 설계할 때 클래스에 대한 가정
        - `선행 조건`, `결과 조건`, `불변 조건`
2. 시스템 타입 결정
    - 대화형 시스템
    - 이벤트 중심 시스템
    - 변환형 시스템
    - 객체 영속형 시스템
3. 아키텍처 패턴 적용: 시스템 타입에 맞는 표준 아키텍처 설계
    - 레이어 패턴: 마주보는 두 개층만 영향을 줌. OSI 참조 모델 같은거
    - 클라이언트-서버 패턴
    - 파이프-필터 패턴
    - 모델-뷰-컨트롤러(MVC) 패턴
    - 마스터-슬레이브 패턴
    - 브로커 패턴: load balancing 말 하는듯
    - p2p 패턴
    - 이벤트-버스 패턴: 메세지큐
    - 블랙보드 패턴
    - 인터프리터 패턴
4. 서브시스템 구체화
5. 검토

## 객체지향 분석

- 럼바우, 부치, Jacobson, Coad / Yourdon(ER Diagram), Wirfs-Brock 등
- 럼바우(OMT):
    1. `객체 모델링`
    2. `동적 모델링`: 시간의 흐름에 따른 객체들 간의 변화 모델링
    3. `기능 모델링`: DFD를 이용하여 프로세스들 간의 자료 흐름을 중심으로 처리 과정 모델링
- 설계 원칙(SOLID):
    - `단일 책임 원칙`: 객체는 단 하나의 책임만 가져야 함
    - `개방-폐쇄 원칙`: 확장에는 열려 있고, 변경에는 닫혀 있어야 함
    - `리스코프 치환 원칙`: 자식 클래스는 부모 클래스를 확장만 함(무시, 재정의 x)
    - `인터페이스 분리 원칙`: 사용하지 않는 인터페이스와 의존 관계를 맺지 않도록 함
    - `의존성 역전 원칙`: 추상성이 높은 클래스에 의존해야 함

## 모듈

### 결합도

- 아래로 갈 수록 결합도 강함(안 좋음)

1. 자료 결합도: 매개변수로만 데이터 전달
1. 스탬프(검인) 결합도: 배열이나 레코드 등의 자료 구조가 전달됨
1. 제어 결합도: flag 변수를 전달함
1. 외부 결합도: 모듈에서 선언한 변수를 다른 모듈에서 참조
1. 공통 결합도: 공통의 영역을 여러 모듈이 참조
1. 내용 결합도: 한 모듈의 내부 기능이나 자료를 직접 참조

### 응집도

- 아래로 갈 수록 응집도 강함(좋음)

1. 우연적 응집도: 모듈의 구성 요소들이 관련 없음
1. 논리적 응집도: 유사한 기능들을 묶음
1. 시간적 응집도: 특정 시간에 실행되는 기능들을 묶음(ex 프로그램 초기화)
1. 절차적 응집도: 모듈 안의 구성 요소들이 순차적으로 수행됨. 데이터를 주고받지는 않음
1. 교환적 응집도: 동일한 입력 데이터 혹은 출력 데이터를 사용하여 서로 다른 기능을 수행함
1. 순차적 응집도: 하나의 기능에서 나온 출력 데이터를 다음 기능의 입력 데이터로 사용
1. 기능적 응집도: 모듈 내 모든 기능들이 단일 문제와 연관됨

- 팬인: 모듈이 다른 모듈로부터 호출되는 횟수
- 팬아웃: 모듈이 다른 모듈을 호출하는 횟수
- 팬인이 높고 팬아웃이 낮은 모듈이 이상적

- NS 차트: 읽기 쉬우나 그리기 어려운 다이어그램

## 디자인 패턴

### 생성 패턴

- 팩토리 메소드(가상 생성자): 
- 추상 팩토리
- 빌더
- 프로토타입
- 싱글톤: 인스턴스가 하나만 생성되도록 보장. 생성자 함수를 private으로 선언

### 구조 패턴

- 어뎁터
- 브릿지
- 컴포지트: 트리 구조
- 데코레이터
- 퍼사드: 인터페이스 wrapper
- 플라이웨이트: 메모리 공유
- 프록시

### 행위 패턴

- 책임 연쇄: 한 객체가 요청을 처리하지 못하면 다음 객체로 넘김
- 커맨드: 요청을 객체의 형태로 캡슐화
- 인터프리터: 언어 parser
- 반복자: 같은 인터페이스를 이용해 집합체의 요소들을 순차적으로 접근
- 중재자
- 메멘토: 특정 상태의 객체를 저장하고 복원
- 옵서버: 한 객체의 상태 변화가 있을 때 의존하는 다른 객체들에게 통지
- 상태: 객체의 상태에 따라 다른 행동을 하도록 함
- 전략: 알고리즘 캡슐화해서 쓰는거
- 템플릿 메소드
- 방문자: 처리 기능을 별도의 클래스로 분리
