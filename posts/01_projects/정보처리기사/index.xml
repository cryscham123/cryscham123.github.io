<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>김형훈의 학습 블로그</title>
<link>https://cryscham123.github.io/posts/01_projects/정보처리기사/</link>
<atom:link href="https://cryscham123.github.io/posts/01_projects/정보처리기사/index.xml" rel="self" type="application/rss+xml"/>
<description>빠르게 따 봅시다</description>
<image>
<url>https://cryscham123.github.io/profile.jpg</url>
<title>김형훈의 학습 블로그</title>
<link>https://cryscham123.github.io/posts/01_projects/정보처리기사/</link>
</image>
<generator>quarto-1.5.56</generator>
<lastBuildDate>Sat, 24 Jan 2026 15:00:00 GMT</lastBuildDate>
<item>
  <title>정보시스템 구축 관리 - 소프트웨어 개발 방법론 활용</title>
  <link>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/06.html</link>
  <description><![CDATA[ 




<p><img src="https://cryscham123.github.io/img/stat-thumb.jpg" class="post-thumbnail img-fluid"></p>
<section id="개발-방법론" class="level2">
<h2 class="anchored" data-anchor-id="개발-방법론">개발 방법론</h2>
<ul>
<li>구조적 방법론: <code>정형화된 분석 절차</code>에 따라 요구사항을 문서화 하는 <code>처리 중심</code> 방법론</li>
<li>정보공학 방법론: <code>데이터 중심</code> 방법론 (ERD)</li>
<li>객체지향 방법론</li>
<li>컴포넌트 기반 방법론</li>
<li>애자일 방법론</li>
<li>제품 개열 방법론</li>
</ul>
</section>
<section id="소프트웨어-재사용" class="level2">
<h2 class="anchored" data-anchor-id="소프트웨어-재사용">소프트웨어 재사용</h2>
<ul>
<li><code>합성 중심</code>: 모듈 끼워 맞추는거</li>
<li><code>생성 중심</code>: 추상화된 컴포넌트를 구체화</li>
</ul>
<section id="소프트웨어-재공학" class="level3">
<h3 class="anchored" data-anchor-id="소프트웨어-재공학">소프트웨어 재공학</h3>
<ul>
<li>분석</li>
<li>재구성: 기능, 외적인 동작은 유지하면서 내부 구조 변경</li>
<li>역공학: 기존 코드를 분석</li>
<li>이식: 기존 소프트웨어를 다른 환경에 이식할 수 있게 변경</li>
</ul>
<p><code>CASE(Computer-Aided Software Engineering)</code>: 구조적 기법, 프로토타이핑, 분산 처리 등의 기법으로 소프트웨어 개발 생산성을 향상시키기 위한 <code>자동화 도구</code></p>
</section>
</section>
<section id="상향식-비용-산정-기법" class="level2">
<h2 class="anchored" data-anchor-id="상향식-비용-산정-기법">상향식 비용 산정 기법</h2>
<ul>
<li>LOC
<ul>
<li>예측치: <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Ctext%7B%EB%82%99%EA%B4%80%EC%B9%98%7D%20+%204%5Ctext%7B%EC%A4%91%EA%B0%84%EC%B9%98%7D%20+%20%5Ctext%7B%EB%B9%84%EA%B4%80%EC%B9%98%7D%7D%7B6%7D"></li>
<li>노력: LOC / 1인당 월 평균 생산 코드 라인 수</li>
<li>개발 비용: 노력 * 단위 비용(인건비 등)</li>
<li>개발 기간: 노력 / 투입 인원</li>
<li>생산성: LOC / 노력</li>
</ul></li>
<li>수학적 산정 기법
<ul>
<li><code>COCOMO</code>: LOC에 기초한 경험적 모델
<ul>
<li><code>조직형</code>: 5만 라인 이하의 소프트웨어</li>
<li><code>반분리형</code>: 30만 라인 이하의 소프트웨어</li>
<li><code>임베디드형</code>: <code>대규모</code> 소프트웨어</li>
</ul></li>
<li><code>Putnam</code>: <code>Rayleigh-Norden 곡선</code>에 기초하여 노력 산정</li>
<li><code>기능 점수(FP)</code>: 소프트웨어 기능 별 가중치를 부여하고 합산하여 노력 산출</li>
</ul></li>
</ul>
</section>
<section id="프로젝트-일정-계획" class="level2">
<h2 class="anchored" data-anchor-id="프로젝트-일정-계획">프로젝트 일정 계획</h2>
<ul>
<li><code>PERT(Program Evaluation and Review Technique)</code>: 결정 경로, 경계 시간, 작업 간 상호 관련성 파악 가능</li>
<li><code>CPM(Critical Path Method)</code>: 프로젝트 일정 계획 및 관리 기법</li>
<li><code>간트 차트</code>: 작업 일정과 진행 상황을 막대 그래프로 표현</li>
</ul>
</section>
<section id="소프트웨어-개발-표준" class="level2">
<h2 class="anchored" data-anchor-id="소프트웨어-개발-표준">소프트웨어 개발 표준</h2>
<ul>
<li><code>ISO/IEC 12207</code>: 소프트웨어 생명주기 프로세스</li>
<li><code>CMMI(Capability Maturity Model Integration)</code>: 개발 조직 업무 능력 및 성숙도 평가 모델
<ul>
<li>초기, 관리, 정의, 정량적 관리, 최적화</li>
</ul></li>
<li><code>SPICE(Software Process Improvement and Capability Determination)</code>: 소프트웨어 프로세스 평가 및 개선 모델</li>
</ul>


</section>

<a onclick="window.scrollTo(0, 0); return false;" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> 맨 위로</a> ]]></description>
  <category>정보처리기사</category>
  <guid>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/06.html</guid>
  <pubDate>Sat, 24 Jan 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>소프트웨어 개발 - 어플리케이션 테스트 관리</title>
  <link>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/05.html</link>
  <description><![CDATA[ 




<p><img src="https://cryscham123.github.io/img/stat-thumb.jpg" class="post-thumbnail img-fluid"></p>
<section id="분류" class="level2">
<h2 class="anchored" data-anchor-id="분류">분류</h2>
<ul>
<li>실행 여부
<ul>
<li>정적 테스트</li>
<li>동적 테스트:
<ul>
<li>화이트박스: 모든 로직을 테스트 (기초 경로 검사, 제어 구조 검사)</li>
<li>블랙 박스: 기능이 작동하는 것을 입증(동치 분할 검사, 경계값 분석, 원인-효과 그래프 검사, 오류 예측 검사, 비교 검사)</li>
</ul></li>
</ul></li>
<li>테스트 기반
<ul>
<li>명세 기반 테스트</li>
<li>구조 기반 테스트</li>
<li>경험 기반 테스트: 체크 리스트</li>
</ul></li>
<li>시각
<ul>
<li>검증 테스트: 개발자 시각</li>
<li>확인 테스트: 사용자 시각</li>
</ul></li>
<li>목적
<ul>
<li>회복</li>
<li>안전(security)</li>
<li>강도(stress)</li>
<li>성능</li>
<li>구조: 복잡도 평가</li>
<li>회귀: 수정 코드에 결함이 없는지 확인</li>
<li>병행: 입력에 따른 결과가 동일한지 비교</li>
</ul></li>
</ul>
</section>
<section id="개발-단계에-따른-테스트" class="level2">
<h2 class="anchored" data-anchor-id="개발-단계에-따른-테스트">개발 단계에 따른 테스트</h2>
<ol type="1">
<li>요구사항</li>
<li>분석</li>
<li>설계</li>
<li>구현</li>
<li>단위 테스트</li>
<li>통합 테스트
<ul>
<li>하향식: 아직 개발 안된 모듈은 스텁 사용</li>
<li>상향식: 아직 개발 안된 모듈은 드라이버 사용</li>
</ul></li>
<li>시스템 테스트</li>
<li>인수 테스트</li>
</ol>
</section>
<section id="테스트-오라클" class="level2">
<h2 class="anchored" data-anchor-id="테스트-오라클">테스트 오라클</h2>
<ul>
<li>테스트 결과가 오랍른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법</li>
<li>참 오라클</li>
<li>샘플링 오라클</li>
<li>추정 오라클</li>
<li>일관성 검사 오라클</li>
</ul>
</section>
<section id="복잡도" class="level2">
<h2 class="anchored" data-anchor-id="복잡도">복잡도</h2>
<ul>
<li>순환 복잡도: E - N + 2</li>
</ul>


</section>

<a onclick="window.scrollTo(0, 0); return false;" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> 맨 위로</a> ]]></description>
  <category>정보처리기사</category>
  <guid>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/05.html</guid>
  <pubDate>Sun, 18 Jan 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>소프트웨어 개발 - 제품 소프트웨어 패키징</title>
  <link>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/04.html</link>
  <description><![CDATA[ 




<p><img src="https://cryscham123.github.io/img/stat-thumb.jpg" class="post-thumbnail img-fluid"></p>
<section id="디지털-저작권-관리drm" class="level2">
<h2 class="anchored" data-anchor-id="디지털-저작권-관리drm">디지털 저작권 관리(DRM)</h2>
<ul>
<li>클리어링 하우스: 디지털 저작권 라이선스 중개 및 발급 수행 기관.</li>
<li>사용자가 콘텐츠를 사용하려면 클리어링 하우스를 통해 라이선스를 발급받아야 함.</li>
<li>관리 기술 요소:
<ul>
<li>암호화</li>
<li>키 관리</li>
<li>암호화 파일 생성</li>
<li>식별 기술</li>
<li>저작권 표현</li>
<li>정책 관리</li>
<li>크랙 방지</li>
<li>인증</li>
</ul></li>
</ul>


</section>

<a onclick="window.scrollTo(0, 0); return false;" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> 맨 위로</a> ]]></description>
  <category>정보처리기사</category>
  <guid>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/04.html</guid>
  <pubDate>Sun, 18 Jan 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>소프트웨어 설계 - 인터페이스 설계</title>
  <link>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/03.html</link>
  <description><![CDATA[ 




<p><img src="https://cryscham123.github.io/img/stat-thumb.jpg" class="post-thumbnail img-fluid"></p>
<section id="인터페이스-요구사항-검증" class="level2">
<h2 class="anchored" data-anchor-id="인터페이스-요구사항-검증">인터페이스 요구사항 검증</h2>
<ol type="1">
<li>검토 계획 수립
<ul>
<li>검토 기준 및 방법</li>
<li>참여자</li>
<li>체크리스트</li>
<li>관련 자료</li>
<li>일정</li>
</ul></li>
<li>검토 및 오류 수정
<ul>
<li>peer review</li>
<li>워크스루: 요구사항 명세서 배포 후, 짧게 회의 진행</li>
<li>인스펙션: 다른 전문가가 검토하는거</li>
<li>주요 항목:
<ul>
<li>완정성, 일관성, 명확성, 기능성, 검증 가능성, 추적 가능성, 변경 용이성</li>
</ul></li>
</ul></li>
<li>베이스라인 설정</li>
</ol>
</section>
<section id="인터페이스-방법-명세화" class="level2">
<h2 class="anchored" data-anchor-id="인터페이스-방법-명세화">인터페이스 방법 명세화</h2>
<ul>
<li>연계 매커니즘:
<ul>
<li>송신 시스템</li>
<li>연계 서버</li>
<li>수신 시스템</li>
</ul></li>
</ul>
<section id="주요-시스템-연계-기술" class="level3">
<h3 class="anchored" data-anchor-id="주요-시스템-연계-기술">주요 시스템 연계 기술</h3>
<ul>
<li>DBLink</li>
<li>API/Open API</li>
<li>연계 솔루션(EAI)</li>
<li>Socket</li>
<li>Web Service(WSDL, SOAP, UDDI)</li>
</ul>
</section>
</section>
<section id="미들웨어-솔루션-명세" class="level2">
<h2 class="anchored" data-anchor-id="미들웨어-솔루션-명세">미들웨어 솔루션 명세</h2>
<ul>
<li>DB</li>
<li>RPC</li>
<li>MOM: message queue</li>
<li>TP-Monitor(OLTP)</li>
<li>ORB</li>
<li>WAS</li>
</ul>


</section>

<a onclick="window.scrollTo(0, 0); return false;" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> 맨 위로</a> ]]></description>
  <category>정보처리기사</category>
  <guid>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/03.html</guid>
  <pubDate>Wed, 14 Jan 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>소프트웨어 설계 - 어플리케이션 설계</title>
  <link>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/02.html</link>
  <description><![CDATA[ 




<p><img src="https://cryscham123.github.io/img/stat-thumb.jpg" class="post-thumbnail img-fluid"></p>
<section id="소프트웨어-아키텍처" class="level2">
<h2 class="anchored" data-anchor-id="소프트웨어-아키텍처">소프트웨어 아키텍처</h2>
<section id="기본-원리" class="level3">
<h3 class="anchored" data-anchor-id="기본-원리">기본 원리</h3>
<ul>
<li>모듈화</li>
<li>추상화: <code>제어</code>, <code>과정</code>, <code>자료(데이터)</code> 추상화가 있다.</li>
<li>단계적 분해</li>
<li>정보 은닉</li>
</ul>
</section>
<section id="소프트웨어-아키텍처의-품질-속성" class="level3">
<h3 class="anchored" data-anchor-id="소프트웨어-아키텍처의-품질-속성">소프트웨어 아키텍처의 품질 속성</h3>
<ul>
<li>시스템 측면</li>
<li>비즈니스 측면</li>
<li>아키텍처 측면: 개념적 무결성, 정확성, 완결성, 구축 가능성 등</li>
</ul>
</section>
<section id="설계-과정" class="level3">
<h3 class="anchored" data-anchor-id="설계-과정">설계 과정</h3>
<ol type="1">
<li>설계 목표 설정
<ul>
<li>협약에 의한 설계: 컴포넌트를 설계할 때 클래스에 대한 가정
<ul>
<li><code>선행 조건</code>, <code>결과 조건</code>, <code>불변 조건</code></li>
</ul></li>
</ul></li>
<li>시스템 타입 결정
<ul>
<li>대화형 시스템</li>
<li>이벤트 중심 시스템</li>
<li>변환형 시스템</li>
<li>객체 영속형 시스템</li>
</ul></li>
<li>아키텍처 패턴 적용: 시스템 타입에 맞는 표준 아키텍처 설계
<ul>
<li>레이어 패턴: 마주보는 두 개층만 영향을 줌. OSI 참조 모델 같은거</li>
<li>클라이언트-서버 패턴</li>
<li>파이프-필터 패턴</li>
<li>모델-뷰-컨트롤러(MVC) 패턴</li>
<li>마스터-슬레이브 패턴</li>
<li>브로커 패턴: load balancing 말 하는듯</li>
<li>p2p 패턴</li>
<li>이벤트-버스 패턴: 메세지큐</li>
<li>블랙보드 패턴</li>
<li>인터프리터 패턴</li>
</ul></li>
<li>서브시스템 구체화</li>
<li>검토</li>
</ol>
</section>
</section>
<section id="객체지향-분석" class="level2">
<h2 class="anchored" data-anchor-id="객체지향-분석">객체지향 분석</h2>
<ul>
<li>럼바우, 부치, Jacobson, Coad / Yourdon(ER Diagram), Wirfs-Brock 등</li>
<li>럼바우(OMT):
<ol type="1">
<li><code>객체 모델링</code></li>
<li><code>동적 모델링</code>: 시간의 흐름에 따른 객체들 간의 변화 모델링</li>
<li><code>기능 모델링</code>: DFD를 이용하여 프로세스들 간의 자료 흐름을 중심으로 처리 과정 모델링</li>
</ol></li>
<li>설계 원칙(SOLID):
<ul>
<li><code>단일 책임 원칙</code>: 객체는 단 하나의 책임만 가져야 함</li>
<li><code>개방-폐쇄 원칙</code>: 확장에는 열려 있고, 변경에는 닫혀 있어야 함</li>
<li><code>리스코프 치환 원칙</code>: 자식 클래스는 부모 클래스를 확장만 함(무시, 재정의 x)</li>
<li><code>인터페이스 분리 원칙</code>: 사용하지 않는 인터페이스와 의존 관계를 맺지 않도록 함</li>
<li><code>의존성 역전 원칙</code>: 추상성이 높은 클래스에 의존해야 함</li>
</ul></li>
</ul>
</section>
<section id="모듈" class="level2">
<h2 class="anchored" data-anchor-id="모듈">모듈</h2>
<section id="결합도" class="level3">
<h3 class="anchored" data-anchor-id="결합도">결합도</h3>
<ul>
<li>아래로 갈 수록 결합도 강함(안 좋음)</li>
</ul>
<ol type="1">
<li>자료 결합도: 매개변수로만 데이터 전달</li>
<li>스탬프(검인) 결합도: 배열이나 레코드 등의 자료 구조가 전달됨</li>
<li>제어 결합도: flag 변수를 전달함</li>
<li>외부 결합도: 모듈에서 선언한 변수를 다른 모듈에서 참조</li>
<li>공통 결합도: 공통의 영역을 여러 모듈이 참조</li>
<li>내용 결합도: 한 모듈의 내부 기능이나 자료를 직접 참조</li>
</ol>
</section>
<section id="응집도" class="level3">
<h3 class="anchored" data-anchor-id="응집도">응집도</h3>
<ul>
<li>아래로 갈 수록 응집도 강함(좋음)</li>
</ul>
<ol type="1">
<li>우연적 응집도: 모듈의 구성 요소들이 관련 없음</li>
<li>논리적 응집도: 유사한 기능들을 묶음</li>
<li>시간적 응집도: 특정 시간에 실행되는 기능들을 묶음(ex 프로그램 초기화)</li>
<li>절차적 응집도: 모듈 안의 구성 요소들이 순차적으로 수행됨. 데이터를 주고받지는 않음</li>
<li>교환적 응집도: 동일한 입력 데이터 혹은 출력 데이터를 사용하여 서로 다른 기능을 수행함</li>
<li>순차적 응집도: 하나의 기능에서 나온 출력 데이터를 다음 기능의 입력 데이터로 사용</li>
<li>기능적 응집도: 모듈 내 모든 기능들이 단일 문제와 연관됨</li>
</ol>
<ul>
<li><p>팬인: 모듈이 다른 모듈로부터 호출되는 횟수</p></li>
<li><p>팬아웃: 모듈이 다른 모듈을 호출하는 횟수</p></li>
<li><p>팬인이 높고 팬아웃이 낮은 모듈이 이상적</p></li>
<li><p>NS 차트: 읽기 쉬우나 그리기 어려운 다이어그램</p></li>
</ul>
</section>
</section>
<section id="디자인-패턴" class="level2">
<h2 class="anchored" data-anchor-id="디자인-패턴">디자인 패턴</h2>
<section id="생성-패턴" class="level3">
<h3 class="anchored" data-anchor-id="생성-패턴">생성 패턴</h3>
<ul>
<li>팩토리 메소드(가상 생성자):</li>
<li>추상 팩토리</li>
<li>빌더</li>
<li>프로토타입</li>
<li>싱글톤: 인스턴스가 하나만 생성되도록 보장. 생성자 함수를 private으로 선언</li>
</ul>
</section>
<section id="구조-패턴" class="level3">
<h3 class="anchored" data-anchor-id="구조-패턴">구조 패턴</h3>
<ul>
<li>어뎁터</li>
<li>브릿지</li>
<li>컴포지트: 트리 구조</li>
<li>데코레이터</li>
<li>퍼사드: 인터페이스 wrapper</li>
<li>플라이웨이트: 메모리 공유</li>
<li>프록시</li>
</ul>
</section>
<section id="행위-패턴" class="level3">
<h3 class="anchored" data-anchor-id="행위-패턴">행위 패턴</h3>
<ul>
<li>책임 연쇄: 한 객체가 요청을 처리하지 못하면 다음 객체로 넘김</li>
<li>커맨드: 요청을 객체의 형태로 캡슐화</li>
<li>인터프리터: 언어 parser</li>
<li>반복자: 같은 인터페이스를 이용해 집합체의 요소들을 순차적으로 접근</li>
<li>중재자</li>
<li>메멘토: 특정 상태의 객체를 저장하고 복원</li>
<li>옵서버: 한 객체의 상태 변화가 있을 때 의존하는 다른 객체들에게 통지</li>
<li>상태: 객체의 상태에 따라 다른 행동을 하도록 함</li>
<li>전략: 알고리즘 캡슐화해서 쓰는거</li>
<li>템플릿 메소드</li>
<li>방문자: 처리 기능을 별도의 클래스로 분리</li>
</ul>


</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> 맨 위로</a> ]]></description>
  <category>정보처리기사</category>
  <guid>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/02.html</guid>
  <pubDate>Tue, 13 Jan 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>소프트웨어 설계 - 화면 설계</title>
  <link>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/01.html</link>
  <description><![CDATA[ 




<p><img src="https://cryscham123.github.io/img/stat-thumb.jpg" class="post-thumbnail img-fluid"></p>
<section id="사용자-인터페이스" class="level2">
<h2 class="anchored" data-anchor-id="사용자-인터페이스">사용자 인터페이스</h2>
<section id="분야" class="level3">
<h3 class="anchored" data-anchor-id="분야">분야</h3>
<ul>
<li>정보 제공과 전달을 위한 <code>물리적 제어</code>에 관한 분야</li>
<li>콘텐츠의 <code>상세적인 표현</code>과 <code>전체적인 구성</code>에 관한 분야</li>
<li><code>모든 사용자</code>가 편리하고 간편하게 사용하도록 하는 기능에 관한 분야</li>
</ul>
</section>
<section id="구분" class="level3">
<h3 class="anchored" data-anchor-id="구분">구분</h3>
<ul>
<li>CLI, GUI</li>
<li>NUI(Natural User Interface): 사용자의 말이나 행동으로 조작. Tap, Double, Drag, Pan, Press, Flick, Pinch</li>
<li>VUI(Voice User Interface)</li>
<li>OUI(Organic User Interface): 모든 사물과 사용자 간의 상호작용을 위한 인터페이스. Iot, VR, AR 등에서 사용됨.</li>
</ul>
</section>
<section id="원칙" class="level3">
<h3 class="anchored" data-anchor-id="원칙">원칙</h3>
<ul>
<li>직관성, 유효성, 학습성, 유연성</li>
</ul>
</section>
<section id="설계-지침" class="level3">
<h3 class="anchored" data-anchor-id="설계-지침">설계 지침</h3>
<ul>
<li>사용자 중심, 사용성, 일관성, 단순성, 결과 예측 가능, 가시성, 심미성, 표준화, 접근성, 명확성, 오류 발생 해결</li>
</ul>
</section>
<section id="개발-시스템의-기능" class="level3">
<h3 class="anchored" data-anchor-id="개발-시스템의-기능">개발 시스템의 기능</h3>
<ul>
<li>사용자의 입력을 검증할 수 있어야 함</li>
<li>에러 처리와 그와 관련된 에러 메시지를 표시할 수 있어야 함</li>
<li>도움과 프롬프트를 제공해야 함</li>
</ul>
</section>
</section>
<section id="ui-설계-도구" class="level2">
<h2 class="anchored" data-anchor-id="ui-설계-도구">UI 설계 도구</h2>
<ul>
<li>와이어프레임: UI 스케치 해보는 거</li>
<li>목업: 와이어프레임보다 더 구체적이지만 여전히 스케치 해보는 거</li>
<li>스토리보드: 와이어프레임 + 콘텐츠에 대한 설명, 페이지 간 이동 흐름</li>
<li>프로토타입: 실제 동작하는 UI</li>
<li>유스케이스: 유스케이스 다이어그램 + 명세서</li>
</ul>
</section>
<section id="품질-요구사항" class="level2">
<h2 class="anchored" data-anchor-id="품질-요구사항">품질 요구사항</h2>
<ul>
<li>ISO/IEC 9126 표준에 따름</li>
<li>ISO/IEC 25010으로 개정됨</li>
</ul>
<ol type="1">
<li>기능성: 적절성, 상호 운용성, 보안성, 준수성</li>
<li>신뢰성: 성숙성, 고장 허용성, 회복성</li>
<li>사용성: 이해성, 친밀성</li>
<li>효율성: 시간, 자원 효율성</li>
<li>유지 보수성: 분석성, 변경성, 안정성, 시험성</li>
<li>이식성: 적용성, 설치성, 대체성, 공존성</li>
</ol>


</section>

<a onclick="window.scrollTo(0, 0); return false;" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> 맨 위로</a> ]]></description>
  <category>정보처리기사</category>
  <guid>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/01.html</guid>
  <pubDate>Tue, 13 Jan 2026 15:00:00 GMT</pubDate>
</item>
<item>
  <title>소프트웨어 설계 - 요구사항 확인</title>
  <link>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/00.html</link>
  <description><![CDATA[ 




<p><img src="https://cryscham123.github.io/img/stat-thumb.jpg" class="post-thumbnail img-fluid"></p>
<section id="소프트웨어-생명수명-주기" class="level2">
<h2 class="anchored" data-anchor-id="소프트웨어-생명수명-주기">소프트웨어 생명(수명) 주기</h2>
<ul>
<li>소프트웨어 개발 방법론<sup>1</sup>의 바탕이 되는 것으로, 소프트웨어를 개발하기 위해 정의하고 운용, 유지보수 등의 과정을 각 단계별로 나눈 것</li>
<li><code>개발 단계</code>, <code>단계별 주요 활동</code>, <code>활동의 산출물</code>로 표현</li>
<li><code>소프트웨어 공학</code>
<ul>
<li>소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문</li>
<li>IEEE 소프트웨어 공학 표준 용어사전: 소프트웨어의 개발, 운용, 유지보수, 폐기 처분에 대한 체계적인 접근 방안</li>
<li>Fairley: 지정된 비용과 시간 내에 소프트웨어를 체계적으로 생산하고 유지보수하는 데 관련된 기술적이고 관리적인 원리</li>
<li>Boehm: 과학적인 지식을 소프트웨어 설계와 제작에 응용하는 것이며 이를 개발, 운용, 유지보수하는데 필요한 문서 작성 과정</li>
<li><code>기본 원칙</code>:
<ul>
<li><code>현대적인 프로그래밍 기술</code>을 계속 적용해야 함</li>
<li>개발된 소프트웨어 품질이 유지되도록 <code>지속적으로 검증</code>해야 함</li>
<li>소프트웨어 개발 관련 사항 및 결과에 대한 명확한 <code>기록을 유지</code>해야 함</li>
</ul></li>
</ul></li>
</ul>
<section id="대표적-모형" class="level3">
<h3 class="anchored" data-anchor-id="대표적-모형">대표적 모형</h3>
<ol type="1">
<li>폭포수 모형
<ul>
<li><code>이전 단계로 돌아갈 수 없다</code>는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후 다음 단계로 진행하는 방식</li>
<li><code>가장 오래되고 폭넓게 사용된 모형</code>. 적용 경험과 성공 사례가 많음</li>
<li>메뉴얼을 작성해야 함</li>
<li><code>결과물이 명확하게 산출</code>되어야 함</li>
<li><code>병행 작업 불가</code></li>
</ul></li>
<li>프로토타입(원형) 모형
<ul>
<li>의뢰자나 개발자 모두에게 공동의 참조 모델이 되는 <code>시제품 개발</code></li>
<li><code>새로운 요구사항이 도출될 때마다 이를 반영</code>한 프로토타입을 새롭게 만듦</li>
<li><code>단기간 제작</code>을 목적으로 함</li>
<li><code>비효율적인 언어나 알고리즘이 사용될 수 있음</code></li>
</ul></li>
<li>나선형(점진적) 모형
<ul>
<li><code>위험 관리</code>에 중점을 둔 모형</li>
<li>핵심 기술에 문제가 있거나 사용자의 요구사항이 이해하기 어려운 경우 적합</li>
<li>각 단계마다 <code>계획</code>, <code>분석</code>, <code>개발</code>, <code>평가</code>의 활동을 반복</li>
<li>점진적으로 개발 과정이 반복되므로 누락되거나 추가된 요구사항을 추가할 수 있고, 유지보수 과정이 필요 없음</li>
</ul></li>
<li>애자일 모형
<ul>
<li>고객과의 소통에 초점을 맞춘 방법론을 통칭</li>
<li>sprint 또는 iteration이라 불리는 짧은 개발 주기를 반복하며 반복되는 주기마다 산출되는 결과물에 대한 고객의 평가와 요구를 적극 수용</li>
<li>4가지 핵심 가치
<ol type="1">
<li>프로세스와 도구보다 개인과 상호작용을 중시</li>
<li>포괄적인 문서화보다 작동하는 소프트웨어를 중시</li>
<li>계약 협상보다 고객과의 협력을 중시</li>
<li>계획을 따르기보다 변화에 대응하는 것을 중시</li>
</ol></li>
<li>12가지 개발 실행 지침
<ol type="1">
<li>유용한 소프트웨어를 빠르고 지속적으로 제공하여 고객을 만족시킨다.</li>
<li>개발 막바지라도 요구사항 변경을 적극 수용한다.</li>
<li>몇 주 단위로 실행되는 소프트웨어를 제공한다.</li>
<li>고객과 개발자가 프로젝트 기간에 함께 일한다.</li>
<li>개발에 대한 참여 의지가 확실한 사람들로 팀을 구성하고, 필요한 개발 환경과 지원을 제공하며, 신뢰한다.</li>
<li>같은 사무실에서 얼굴을 맞대고 의견을 나눈다.</li>
<li>개발 진척도를 확인하는 1차 기준은 작동하는 소프트웨어이다.</li>
<li>지속 가능한 개발을 장려하고 일정한 속도로 개발을 진행한다.</li>
<li>기술적 우수성과 좋은 설계에 지속적으로 집중한다.</li>
<li>단순함을 극대</li>
<li>자율적인 팀이 최선의 아키텍처, 요구사항, 설계를 만들어낸다.</li>
<li>정기적으로 팀의 작업 방식을 되돌아보고, 더 효과적인 방법을 찾아 적용한다.</li>
</ol></li>
</ul></li>
</ol>
</section>
</section>
<section id="스크럼-기법" class="level2">
<h2 class="anchored" data-anchor-id="스크럼-기법">스크럼 기법</h2>
<ul>
<li>럭비에서 반칙으로 경기가 중단된 경우, 양 팀의 선수들이 럭비공을 가운데 두고 상대팀을 밀치기 위해 서로 대치해 있는 대형
<ul>
<li>팀의 중요성을 강조하는 용어</li>
</ul></li>
<li>팀원 <code>스스로가 스크럼 팀을 구성</code>해야 하며, 개발 작업에 관한 모든 것을 <code>스스로 해결할 수 있어야 한다</code>.</li>
</ul>
<section id="구성" class="level3">
<h3 class="anchored" data-anchor-id="구성">구성</h3>
<ul>
<li><code>제품 책임자</code>
<ul>
<li>이해관계자들 중 개발될 제품에 대한 이해도가 높고, 요구사항을 책임지고 의사 결정할 사람</li>
<li>주로 개발 의뢰자나 사용자가 담당</li>
<li><code>백로그 작성(팀원들도 가능)</code> 및 <code>우선순위 지정</code></li>
</ul></li>
<li><code>스크럼 마스터</code>
<ul>
<li>고문 담당</li>
<li>일일 스크럼 회의를 주관</li>
</ul></li>
<li><code>개발 팀</code>
<ul>
<li>개발자, 디자이너, 테스터 등 실제 개발 작업을 수행하는 팀원 통칭</li>
<li>7~8 명</li>
</ul></li>
</ul>
</section>
<section id="프로세스" class="level3">
<h3 class="anchored" data-anchor-id="프로세스">프로세스</h3>
<ol type="1">
<li>제품 백로그: 제품 개발에 필요한 모든 요구사항(user story)을 우선순위에 따라 정리한 목록</li>
<li>스프린트 계획 회의
<ul>
<li>백로그 중 이번 스프린트에서 수행할 작업을 대상으로 <code>단기 일정 수립</code>(2~4주)</li>
<li>백로그를 task 단위로 세분화 해서 개발자 별로 수행할 작업 목록인 <code>스프린트 백로그 작성</code></li>
</ul></li>
<li>스프린트
<ul>
<li>task의 velocity를 기반으로 개발자에게 작업 할당 혹은 개발자가 스스로 작업 선택</li>
<li>할일, 진행 중, 완료의 상태를 가짐.</li>
</ul></li>
<li>일일 스크럼 회의
<ul>
<li>모든 팀원이 매일약속된 시간에 15분 정도의 짧은 시간동안 진행 상황을 점검</li>
<li>남은 작업 시간은 소멸 차트에 표시</li>
</ul></li>
<li>스프린트 검토 회의
<ul>
<li>부분 또는 전체 완성 제품이 요구사항에 잘 부합하는지 사용자가 포함된 참석자 앞에서 테스팅</li>
</ul></li>
<li>스프린트 회고</li>
</ol>
</section>
</section>
<section id="xp익스트림-프로그래밍-기법" class="level2">
<h2 class="anchored" data-anchor-id="xp익스트림-프로그래밍-기법">XP(익스트림 프로그래밍) 기법</h2>
<ul>
<li>릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높이는 기법</li>
<li>핵심 가치: 의사소통, 단순성, 용기, 존중, 피드백</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/img/2026-01-13-00-14-39.png" class="img-fluid figure-img"></p>
<figcaption>개발 프로세스</figcaption>
</figure>
</div>
<ul>
<li>스파이크: 잘 모르는 프로그램 그냥 간단하게 데모로 만들어 보는 것</li>
<li>iteration: 하나의 릴리즈를 세분화 한 단위. 일반적으로 1~3주</li>
<li>승인 검사: iteration 완료 후 고객이 직접 수행</li>
</ul>
<section id="주요-실천-방법" class="level3">
<h3 class="anchored" data-anchor-id="주요-실천-방법">주요 실천 방법</h3>
<ol type="1">
<li>pair programming: 혼자 개발하지 마라</li>
<li>collective ownership: 코드 권한, 책임 공유</li>
<li>test-driven development: 코드 작성 전 테스트 케이스를 먼저 작성. 테스트는 자동화된 도구 사용</li>
<li>whole team: 개발에 참여하는 모든 구성원들은 각자 자신의 역할이 있고, 책임을 가져야 함.</li>
<li>continuous integration</li>
<li>design improvement / refactoring</li>
<li>small releases</li>
</ol>
</section>
</section>
<section id="현행-시스템-파악" class="level2">
<h2 class="anchored" data-anchor-id="현행-시스템-파악">현행 시스템 파악</h2>
<ol type="1">
<li>단계
<ul>
<li>시스템 구성 파악: <code>기간 업무</code>, <code>지원 업무</code>로 구분하여 기술</li>
<li>시스템 기능 파악</li>
<li>시스템 인터페이스 파악: 데이터 형식, 통신 규약, 연계 유형(EAI, FEP 등) 파악</li>
</ul></li>
<li>단계
<ul>
<li>아키텍처 구성 파악</li>
<li>소프트웨어 구성 파악: 소프트웨어들의 제품명, 용도, <code>라이선스 적용 방식</code>, <code>라이선스 수</code> 등 파악</li>
</ul></li>
<li>단계
<ul>
<li>하드웨어 구성 파악: 서버의 주요 사양, 수량, <code>이중화 적용 여부</code> 명시</li>
<li>네트워크 구성 파악</li>
</ul></li>
</ol>
</section>
<section id="개발-기술-환경-파악" class="level2">
<h2 class="anchored" data-anchor-id="개발-기술-환경-파악">개발 기술 환경 파악</h2>
<ul>
<li>운영체제 관련 요구사항 식별 시 고려사항
<ul>
<li>가용성, 성능, 기술 지원, 주변 기기, 구축 비용</li>
</ul></li>
<li>DBMS 관련 요구사항 식별 시 고려사항
<ul>
<li>가용성, 성능, 기술지원, 상호 호환성, 구축 비용</li>
</ul></li>
<li>WAS 관련 요구사항 식별 시 고려사항
<ul>
<li>가용성, 성능, 기술지원, 구축 비용</li>
</ul></li>
</ul>
</section>
<section id="요구사항-정의" class="level2">
<h2 class="anchored" data-anchor-id="요구사항-정의">요구사항 정의</h2>
<section id="유형" class="level3">
<h3 class="anchored" data-anchor-id="유형">유형</h3>
<ul>
<li>기술하는 내용
<ul>
<li>기능 요구사항</li>
<li>비기능 요구사항</li>
</ul></li>
<li>대상의 범위
<ul>
<li>사용자 요구사항: 사용자 관점에서 시스템이 제공해야 할 요구사항</li>
<li>시스템 요구사항: 개발자 관점에서 본 시스템이 제공해야 할 요구사항</li>
</ul></li>
</ul>
</section>
<section id="개발-프로세스" class="level3">
<h3 class="anchored" data-anchor-id="개발-프로세스">개발 프로세스</h3>
<ol type="1">
<li>타당성 조사: 개발 프로세스가 비즈니스 목적에 부합한지, 예산은 적정한지 조사</li>
<li>도출
<ul>
<li>관련 사람들이 서로 의견을 교환하며 <code>요구사항이 어디에 있는지</code>, <code>어떻게 수집할 것</code>인지 식별</li>
<li>청취, 인터뷰, 브레인 스토밍, 프로토타이핑, 유스케이스 등</li>
</ul></li>
<li>분석
<ul>
<li><code>소프트웨어 개발의 실제적인 첫 단계</code>, 사용자의 요구사항을 <code>이해</code>하고 <code>문서화</code>하는 활동을 의미</li>
<li>타당성 조사, 제약 설정, 중복 제거, 소프트웨어 범위 파악 등</li>
<li><code>Agile</code>, <code>UML</code>, <code>자료 흐름도(DFD)</code>, <code>자료 사전(DD)</code> 등의 도구가 사용됨
<ul>
<li>자료 흐름도(자료 흐름 그래프, 버블 차트)
<ul>
<li>프로세스: 원, 자료 흐름: 화살표, 자료 저장소: top-bottom border, 단말: 네모</li>
<li>처리를 거칠 때 마다 새로운 자료 흐름 이름 부여</li>
<li>출력은 반드시 입력이 필요. 역은 성립하지 않음</li>
</ul></li>
<li>자료 사전: 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것(메타 데이터)
<ul>
<li>=: 자료의 정의(구성 요소)</li>
<li><img src="https://latex.codecogs.com/png.latex?%5C%7B%5C%7D_n">: n번 이상 반복, <img src="https://latex.codecogs.com/png.latex?%5C%7B%5C%7D%5En">: 최대 n 번 반복</li>
<li>(): optional</li>
<li>+: and, []: or</li>
<li>* *: 주석</li>
</ul></li>
</ul></li>
</ul></li>
<li>명세
<ul>
<li>정형 명세 기법
<ul>
<li>일관성 있고 간결하지만 이해하기 어려움</li>
<li>VDM, Z, Petri net, CSP 등</li>
</ul></li>
<li>비정형 명세 기법
<ul>
<li>자연어로 작성되어 이해하기 쉬우나, 모호하고 일관성이 떨어짐</li>
<li>FSM, Decision Table, ER 모델링, State Chart 등</li>
</ul></li>
</ul></li>
<li>확인
<ul>
<li>요구사항 관리 도구를 이용하여 <code>형상관리</code> 수행</li>
</ul></li>
</ol>
</section>
<section id="요구사항-분석-case자동화-도구" class="level3">
<h3 class="anchored" data-anchor-id="요구사항-분석-case자동화-도구">요구사항 분석 CASE(자동화 도구)</h3>
<ul>
<li><code>SADT</code>(Structured Analysis and Design Technique)</li>
<li><code>SREM</code>(Software Requirements Engineering Methodology)
<ul>
<li><code>RSL</code>(Requirements Statement Language): 요소, 속성, 관계, 구조들을 기술하는 언어</li>
<li><code>REVS</code>(Requirements Engineering and Validation System): RSL로 기술된 요구사항들을 자동으로 분석하여 명세서를 출력하는 도구</li>
</ul></li>
<li><code>PSL/PSA</code>(Problem Statement Language/Problem Statement Analyzer): SREM이랑 비슷함</li>
<li><code>TAGS</code>(Technology for Automated Generation of Systems): IORL, IORL 처리 도구, TAGS 방법론으로 구성</li>
<li><code>HIPO</code>(Hierarchy Input Process Output): 입력, 처리, 출력으로 구성되며 하향식 소프트웨어 개발을 위한 문서화 도구
<ul>
<li>HIPO Chart 종류:
<ul>
<li>가시적 도표: 목차</li>
<li>총체적 도표: 개요</li>
<li>세부적 도표: 상세 도표</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section id="umlunified-modeling-language" class="level2">
<h2 class="anchored" data-anchor-id="umlunified-modeling-language">UML(Unified Modeling Language)</h2>
<ul>
<li>모두를 위한 객체지향 모델링 언어</li>
</ul>
<section id="사물" class="level3">
<h3 class="anchored" data-anchor-id="사물">사물</h3>
<ul>
<li><code>구조 사물</code>: 노드, 클래스, 컴포넌트 등</li>
<li><code>행동 사물</code>: 시간과 공간에 따른 요소들의 행위 (상호작용, 상태 머신 등)</li>
<li><code>그룹 사물</code></li>
<li><code>주해 사물</code>: 부가 설명</li>
</ul>
</section>
<section id="관계" class="level3">
<h3 class="anchored" data-anchor-id="관계">관계</h3>
<ul>
<li>연관 관계: <code>실선</code>으로 표현. 양방향의 경우 화살표 생략 가능
<ul>
<li>0, 1, n: 연관된 객체의 갯수</li>
<li>*: 연관된 객체가 다수일 수 있음을 의미</li>
<li>1..n: 최소 1개에서 최대 n개</li>
</ul></li>
<li>집합 관계: <code>속이 빈 마름모</code>로 표현. 서로 독립적인 객체 간 포함 관계</li>
<li>포함 관계: <code>속이 찬 마름모</code>. 서로 독립적이지 않은 포함 관계</li>
<li>일반화 간계: <code>속이 빈 화살표</code></li>
<li>의존 관계: <code>점선 화살표</code></li>
<li>실체화 관계: <code>점선 속이 빈 화살표</code></li>
</ul>
</section>
<section id="다이어그램" class="level3">
<h3 class="anchored" data-anchor-id="다이어그램">다이어그램</h3>
<ul>
<li>구조적 다이어 그램: <code>정적</code> 모델링
<ul>
<li>클래스 다이어그램
<ul>
<li>class: 일반적으로 3개의 획으로 나눠 클래스 이름, 속성, 오퍼레이션을 표기함</li>
<li>제약 조건: 입력될 값에 대한 조건, 오퍼레이션(함수) 전후에 지정해야 할 조건
<ul>
<li>+: public, -: private, #: protected, ~: package</li>
</ul></li>
<li>관계: 연관, 집합, 포함, 일반화, 의존</li>
</ul></li>
<li>객체 다이어그램: 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현</li>
<li>컴포넌트 다이어그램: 구현 단계에서 실제 컴포넌트 간의 관계나 인터페이스 표현</li>
<li>배치(deployment) 다이어그램: 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현</li>
<li>복합체 구조 다이어그램: 클래스나 컴포넌트의 내부 구조 표현</li>
<li>패키지 다이어그램: 유스케이스나 클래스 등의 모델 요소들을 그룹화한 관계 표현</li>
</ul></li>
<li>행동 다이어그램: <code>동적</code> 모델링
<ul>
<li>유스케이스 다이어그램: <code>사용자</code>, 사용 사례로 구성. 사용 사례 간 여러 관계 표현
<ul>
<li>시스템: 시스템 내부에서 수행되는 기능들을 사각형으로 묶어 표현</li>
<li>액터: 시스템과 상호작용 하는 모든 외부 요소
<ul>
<li>주액터: 시스템을 사용함으로써 이득을 얻는 대상</li>
<li>부액터: 주액터의 목적 달성을 위해 서비스를 제공하는 외부 시스템</li>
</ul></li>
<li>유스케이스: 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스</li>
<li>관계: 연관, 포함, 확장, 일반화</li>
</ul></li>
<li>순차 다이어그램: 객체 간 메세지 표현
<ul>
<li>액터: 외부 시스템</li>
<li>객체: 메시지를 주고받는 주체</li>
<li>생명선: 객체가 메모리에 존재하는 기간</li>
<li>실행 상자: 객체가 메시지를 주고받고 있음을 표현</li>
<li>메시지</li>
<li>회귀 메시지(reply message)</li>
<li>제어 블록(loop)</li>
</ul></li>
<li>커뮤니케이션 다이어그램: 순차랑 비슷함</li>
<li>상태 다이어그램: 이벤트에 의한 객체들의 변화 표현</li>
<li>활동 다이어그램: 객체의 처리 흐름 표현</li>
<li>상호작용 개요 다이어그램: 제어 흐름 표현</li>
<li>타이밍 다이어그램: 활동 다이어그램이랑 비슷함</li>
</ul></li>
</ul>


</section>
</section>


<a onclick="window.scrollTo(0, 0); return false;" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> 맨 위로</a><div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">각주</h2>

<ol>
<li id="fn1"><p>소프트웨어 개발과 유지보수 등에 필요한 작업들의 수행 방법 및 필요 기법을 표준화한 것↩︎</p></li>
</ol>
</section></div> ]]></description>
  <category>정보처리기사</category>
  <guid>https://cryscham123.github.io/posts/01_projects/정보처리기사/notes/00.html</guid>
  <pubDate>Fri, 09 Jan 2026 15:00:00 GMT</pubDate>
</item>
</channel>
</rss>
