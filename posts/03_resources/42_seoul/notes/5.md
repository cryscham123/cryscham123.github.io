---
title: "cloud-1"
date: 2025-01-26
categories: ["aws", "terraform", "ansible", "42 seoul"]
---

![](/img/stat-thumb.jpg){.post-thumbnail}

::: {.callout-note appearance="simple"}
아직 작성중인 노트입니다.
:::

## intro

![42 seoul outer 과제](/img/42-outer-1.png)

다음 학기 시작 전까지 개념공부만 하면서 시간을 보내려고 하니까 프로젝트가 하고 싶어졌습니다.
원래는 python 과제를 하려고 했는데, 이전에 cloud 과제를 진행하다가 말았던게 기억나서 이어서 해보면 괜찮겠다 생각했습니다.

## 프로젝트 및 구현 설명

### 개요

[과제 명세서](https://cdn.intra.42.fr/pdf/pdf/147805/en.subject.pdf)

참고한 자료는 다음과 같습니다:

- [AWS SAA Udemy 강의](https://www.udemy.com/course/aws-certified-solutions-architect-associate-saa-c03/)
- [ansible terraform Udemy 강의](https://www.udemy.com/course/terraform-and-ansible/?utm_campaign=2025-01-21&utm_content=promo&utm_medium=4897172&utm_source=email-sendgrid&utm_term=38475056)

이 강의들도 본 지 1년이 다되어가긴 하지만..과제할 때 사용한 제 배경지식이 여기서 나온거니까요.
과제를 진행하실 분들은 한번 수강해보시면 도움이 될 것 같습니다.

::: {.callout-note appearance="simple"}
이 포스팅에서 docker와 nginx, wordpress, mysql 구조에 대한 설명은 생략하겠습니다.  
전체 코드는 [github repo](https://github.com/cryscham123/cloud-1)에서 확인하실 수 있습니다.
:::

### 전체적인 구조

![구현 aws 구조]()

public subnet에 있는 ec2들은 머신들을 자동으로 세팅하는 컴퓨터에서만 접근이 가능하도록 설정해주었습니다.

mysql의 data들은 전부 private subnet의 efs에 저장해주었고, efs는 public subnet의 ec2만 접근 가능하도록 해주었습니다.

조금 더 일반적인 구조로 구현하고 싶다면, database는 aws RDS를 이용하고, wordpress의 file system을 efs로 관리하거나, aws s3를 이용해서 stateless하게 구현하는게 더 좋습니다.

또, ec2 머신들을 auto scaling group으로 묶어주고, 그 앞에 network load balancer를 provision해서 하나의 endpoint를 만들어주는게 좋습니다.

따라서 아래의 그림이 조금 더 일반적인 구조입니다.

![일반적인 aws 구조]()

과제 요구사항을 맞추다보니 조금 다르게 구현이 됐습니다.

제 구현에서는 server들이 상태도, endpoint도 따로 가지고 있습니다.

저는 machine provision 용도로 terraform, 환경 세팅 용도로 ansible을 이용했습니다.

### Terraform 코드

```{.python filename=variable.tf}
variable "AWS_REGION" {
  type        = string
  description = "The region in which AWS resources will be created"
}

variable "SERVER_INSTANCE_COUNT" {
  description = "Number of server instances"
  type        = number
}

variable "SSH_PUBLIC_KEY_PATH" {
  description = "Path for SSH public key"
  type        = string
}

variable "SSH_IP" {
  description = "IP for SSH access"
  type        = string
}

variable "SERVER_INGRESS_RULES" {
  description = "List of ingress rules"
  type = list(object({
    from_port       = number
    to_port         = number
    protocol        = string
    cidr_blocks     = list(string)
    security_groups = list(string)
  }))
  default = [
    {
      from_port       = 22
      to_port         = 22
      protocol        = "tcp"
      cidr_blocks     = []
      security_groups = []
    },
    {
      from_port       = 80
      to_port         = 80
      protocol        = "tcp"
      cidr_blocks     = ["0.0.0.0/0"]
      security_groups = []
    },
    {
      from_port       = 443
      to_port         = 443
      protocol        = "tcp"
      cidr_blocks     = ["0.0.0.0/0"]
      security_groups = []
    }
  ]
}
```

```{.python filename=main.tf}
resource "aws_key_pair" "my_labtop" {
  key_name   = "my_labtop"
  public_key = file(var.SSH_PUBLIC_KEY_PATH)
}

module "network" {
  source = "../modules/network"

  AWS_REGION           = var.AWS_REGION
  SERVER_INGRESS_RULES = var.SERVER_INGRESS_RULES
  SSH_CIDR_BLOCKS      = ["${var.SSH_IP}/32"]
}

resource "aws_efs_file_system" "efs" {
  creation_token   = "docker-efs"
  encrypted        = true
  performance_mode = "generalPurpose"
  throughput_mode  = "bursting"
}

resource "aws_efs_mount_target" "efs_mount" {
  file_system_id  = aws_efs_file_system.efs.id
  subnet_id       = module.network.private_subnets
  security_groups = [module.network.efs_sg_id]
}

resource "aws_instance" "server" {
  count         = var.SERVER_INSTANCE_COUNT
  ami           = data.aws_ami.latest_ubuntu.id
  instance_type = "t2.micro"

  vpc_security_group_ids = [module.network.server_sg_id]
  subnet_id              = module.network.public_subnets[count.index % 2]

  key_name = aws_key_pair.my_labtop.key_name
  tags = {
    Name = "serverNode"
  }
}
```

### ansible 코드


### build

```{.python filename=Makefile}
PROVISION_PATH=terraform/main
DEPLOY_PATH=ansible
include .env
export

.PHONY: provision deploy all destroy re

all: provision deploy

provision: terraform
	terraform -chdir=$(PROVISION_PATH) init
	terraform -chdir=$(PROVISION_PATH) apply -auto-approve

deploy: ansible
	@EFS_PRIVATE_IP=$(shell terraform -chdir=$(PROVISION_PATH) output efs_private_ip) \
	ANSIBLE_HOST_KEY_CHECKING=False \
	ANSIBLE_REMOTE_USER=ubuntu \
	ansible-playbook \
	-i $(DEPLOY_PATH)/inventories \
	--private-key=$(SSH_PRIVATE_KEY_PATH) \
	$(DEPLOY_PATH)/main.yml 

destroy: terraform
	terraform -chdir=$(PROVISION_PATH) destroy -auto-approve

re: destroy all
```

최종 build는 (42 seoul 사람에게 익숙한) makefile을 사용했습니다.

모든 변수는 .env로 관리하고 makefile 내부에서 환경변수를 가져와서 terraform과 ansible 명령어를 실행해주었습니다.

## 결과

아직 평가 전입니다.

## outro

솔직히 일반적으로 사용되는 cloud 구조를 적용한건 아니긴 하지만, 과제에 맞춰서 진행하기 위해 고민하는 과정에서 다양한 구조를 적용해봤는데, 그 과정이 나름 학습에 도움이 된거 같습니다.

그렇다고 cloud를 처음 공부하시는 분들에게 학습 용도로 추천할만한 과제까지는 아닌거 같지만, 이 분야에 공부를 꽤 했고, 그 내용들을 다양하게 고민하며 적용해보고 싶다면 괜찮은 선택지가 될 것 같습니다.

그나저나 cloud-1 과제는 있는데 왜 cloud-2, 3, 4 과제는 없는거죠? ..이제 진짜 할만한 프로젝트가 없네요. 다시 개념공부나 하러 가야겠습니다.
