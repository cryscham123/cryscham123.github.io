---
title: "cloud-1 코드 설명"
categories: ["aws", "packer", "terraform", "ansible", "42 seoul"]
---

![](/img/stat-thumb.jpg){.post-thumbnail}

::: {.callout-note appearance="simple"}
아직 작성중인 노트입니다.
:::

## intro

![42 seoul outer 과제](/img/42-outer-1.png)

[개념 설명](./5.md)에 이어서 진행하도록 하겠습니다.

::: {.callout-note appearance="simple"}
전체 코드는 [github repo](https://github.com/cryscham123/cloud-1)에서 확인하실 수 있습니다.
:::

## 프로젝트 및 구현 설명

### build

최종 build는 (42 seoul 사람에게 익숙한) `makefile`을 사용했습니다.

::: {.callout-note appearance="simple"}
제가 아직 로컬에서 돌려볼만한 다른 build 툴을 배우지 않아서 makefile을 사용하긴 했지만, 사실 c언어도 아니고..이 과제 구현에서 이 tool이 그렇게 어울리진 않은거 같긴 합니다.
:::

```{.python filename=.env}
# only 1 line variable is allowed

AWS_REGION=
SERVER_INSTANCE_COUNT=

# public subnet에 접근할 수 있는 ip address를 지정해줍니다.
SSH_IP=

# public subnet에 접근할 때 사용할 ssh key path를 지정해줍니다.
SSH_PUBLIC_KEY_PATH=
SSH_PRIVATE_KEY_PATH=

# docker compose setting
MYSQL_USER=
MYSQL_PASSWORD=
MYSQL_ROOT_PASSWORD=
DATABASE_NAME=
SITE_TITLE=
ADMIN_NAME=
ADMIN_PASSWORD=
ADMIN_EMAIL=
USER_NAME=
USER_PASSWORD=
USER_EMAIL=
```

```{.python filename=Makefile}
# .env의 내용들을 makefile의 변수로 load 해줍니다.

include .env
export
```

먼저 `필요한 변수들`을 모두 `.env`에 저장해 `한번에 관리`할 수 있게 구현했습니다.
저장된 .env 내용은 makefile에서 위의 명령어로 불러와 build 명령어 실행시 사용할 수 있게 했습니다.

makefile이 .env 파일을 읽을 때 한 줄씩 읽기 때문에, 위의 방식으로 구현하면 여러 줄에 걸친 환경변수는 사용하기 어려울 수 있습니다.
(그럴땐 그냥 makefile 말고 다른 tool을 쓰면 됩니다)

```{.python filename=Makefile}
.PHONY: provision deploy all destroy re build_ami

all: provision deploy

build_ami: packer
	packer init $(PACKER_PATH)/database.pkr.hcl
	@PKR_VAR_AWS_REGION=$(AWS_REGION) \
	PKR_VAR_MYSQL_USER=$(MYSQL_USER) \
	PKR_VAR_MYSQL_PASSWORD=$(MYSQL_PASSWORD) \
	PKR_VAR_DATABASE_NAME=$(DATABASE_NAME) \
	PKR_VAR_MYSQL_ROOT_PASSWORD=$(MYSQL_ROOT_PASSWORD) \
	packer build $(PACKER_PATH)/database.pkr.hcl

provision: build_ami terraform
	terraform -chdir=$(PROVISION_PATH) init
	@TF_VAR_AWS_REGION=$(AWS_REGION) \
	TF_VAR_SERVER_INSTANCE_COUNT=$(SERVER_INSTANCE_COUNT) \
	TF_VAR_SSH_IP=$(SSH_IP) \
	TF_VAR_SSH_PUBLIC_KEY_PATH=$(SSH_PUBLIC_KEY_PATH) \
	terraform -chdir=$(PROVISION_PATH) apply -auto-approve

deploy: ansible
	@DB_PRIVATE_IP="$(shell terraform -chdir=$(PROVISION_PATH) output -json db_private_ip | jq -r '.[]' | tr '\n' ' ')" \
	ANSIBLE_HOST_KEY_CHECKING=False \
	ANSIBLE_REMOTE_USER=ubuntu \
	ansible-playbook \
	-i $(DEPLOY_PATH)/inventories \
	--private-key=$(SSH_PRIVATE_KEY_PATH) \
	$(DEPLOY_PATH)/server.yml 
```

build 과정은 `ami 생성`, `provision`, `ansible deploy` 순서로 진행됩니다.

각 과정에 필요한 변수들은 `명령어 수행 시 환경변수로 제공`해줍니다.
대표적으로 ansible의 경우, provision 이후 생성된 database ec2의 private ip를 전달하고 있습니다.

### Packer 코드

이 프로젝트에서는 데이터베이스 서버를 Private subnet에 위치시키고, Public subnet의 EC2만 이 데이터베이스에 접근할 수 있도록 설계했습니다. `Private subnet에 있는 서버`는 SSH 접근이 제한되기 때문에 `Ansible로 직접 설정하기가 어렵습니다.` 이런 경우 `Packer를 사용하여 미리 설정된 AMI를 생성`하는 것이 좋은 해결책이 될 수 있습니다.

packer의 파일 구조는 아래와 같습니다.

```bash
packer/
├── database.pkr.hcl
└── ansible/
    ├── _requirements/                      # docker compose setting files
    ├── roles/setting_docker/tasks
    │   └── main.yml
    └── database.yml                        # playbook
```

먼저 `기본 이미지로 Ubuntu 20.04`를 사용하도록 작성했습니다.

```{.python filename=database.pkr.hcl}
source "amazon-ebs" "database" {
  region  = var.AWS_REGION
  profile = "default"

  ami_name      = "hyunghki-database-${formatdate("YYYYMMDDhhmmss", timestamp())}"
  instance_type = "t2.micro"
  source_ami_filter {
    filters = {
      name                = "ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"
      root-device-type    = "ebs"
      virtualization-type = "hvm"
    }
    most_recent = true
    owners      = ["099720109477"]
  }
  ssh_username = "ubuntu"
}
```

Packer는 기본적으로 이미지 생성을 위한 최소한의 기능만 제공하지만, 다양한 플러그인을 지원합니다.
여기서는 `Ansible 플러그인을 사용`하여 데이터베이스 서버 설정을 자동화했습니다.

```{.python filename=database.pkr.hcl}
build {
  sources = ["source.amazon-ebs.database"]

  provisioner "ansible" {
    playbook_file = "${path.root}/ansible/database.yml"
    user = "ubuntu"
    ansible_env_vars = [
      "ANSIBLE_HOST_KEY_CHECKING=False",
      "MYSQL_USER=${var.MYSQL_USER}",
      "MYSQL_PASSWORD=${var.MYSQL_PASSWORD}",
      "DATABASE_NAME=${var.DATABASE_NAME}",
      "MYSQL_ROOT_PASSWORD=${var.MYSQL_ROOT_PASSWORD}"
    ]
  }
}
```

```{.python filename=ansible/database.yml}
- hosts: all
  gather_facts: false
  become: true
  roles:
    # docker compose를 machine에 설치해줍니다.
    - role: setting_docker

  tasks:
    # docker compose에 필요한 파일들을 옮겨줍니다.
    - name: copy_requirements
      copy:
        src: "./_requirements/"
        dest: "/home/{{ ansible_user }}/app/"
        mode: '0755'
        directory_mode: '0755'

    # 적절한 환경변수와 함께 docker compose 명령어를 실행합니다.
    - name: execute docker compose
      shell:
        cmd: docker-compose up -d
        chdir: "/home/{{ ansible_user }}/app/"
      environment:
        MYSQL_USER: "{{ lookup('env', 'MYSQL_USER') }}"
        MYSQL_PASSWORD: "{{ lookup('env', 'MYSQL_PASSWORD') }}"
        DATABASE_NAME: "{{ lookup('env', 'DATABASE_NAME') }}"
        MYSQL_ROOT_PASSWORD: "{{ lookup('env', 'MYSQL_ROOT_PASSWORD') }}"
```

이렇게 Ansible과 Packer를 조합하면 `멱등성이 보장되는 안정적인 서버 이미지를 생성`할 수 있습니다.

참고로 packer에서 ansible plugin을 사용할 때 `taget host를 ami가 build되는 임시 EC2로 간주`하기 때문에, `inventory는 사용하지 않습니다.`
자세한 내용은 [ansible part](#ansible-코드)를 참고해주세요.

### Terraform 코드

이제 본격적으로 provision을 해보겠습니다.


### ansible 코드

이제 software 세팅을 시작하겠습니다.

## 결과

아직 평가 전입니다.

## outro

솔직히 일반적으로 사용되는 cloud 구조를 적용한건 아니긴 하지만, 과제에 맞춰서 진행하기 위해 고민하는 과정에서 다양한 구조를 적용해봤는데, 그 과정이 나름 학습에 도움이 된거 같습니다.
이 분야에 공부를 꽤 했고, 그 내용들을 다양하게 고민하며 적용해보고 싶다면 이 프로젝트가 괜찮은 선택지가 될 수도 있어 보입니다.
